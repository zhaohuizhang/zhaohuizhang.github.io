<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Welcome To Napu&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="This is zhaohuizhang&apos;s blog site">
<meta property="og:type" content="website">
<meta property="og:title" content="Welcome To Napu's Blog">
<meta property="og:url" content="http://zhaohuizhang.github.io/index.html">
<meta property="og:site_name" content="Welcome To Napu's Blog">
<meta property="og:description" content="This is zhaohuizhang&apos;s blog site">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Welcome To Napu's Blog">
<meta name="twitter:description" content="This is zhaohuizhang&apos;s blog site">
  
    <link rel="alternative" href="/atom.xml" title="Welcome To Napu&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Welcome To Napu&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hello world，have a nice day!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://zhaohuizhang.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-java-environment" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/15/java-environment/" class="article-date">
  <time datetime="2016-03-15T01:52:10.000Z" itemprop="datePublished">2016-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/15/java-environment/">java-environment</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java环境介绍">Java环境介绍</h1><h2 id="Java语言、JVM和生态系统">Java语言、JVM和生态系统</h2><p>Java编译环境出现于20世纪90年代末，由Java语言和运行时组成。运行时也叫Java虚拟机（Java Virtual Machine， JVM）。</p>
<h3 id="1-1_JVM_是什么">1.1 JVM 是什么</h3><p>JVM是一个程序，提供了运行Java程序所需要的运行时环境。如果某个硬件和操作系统平台没有响应的JVM，就不能运行Java程序。</p>
<p>提供给JVM运行的程序不是Java语言源码，源码必须转换成一种称为Java字节码的格式。提供给JVM的Java字节码必须是类文件格式，扩展名为’.Class’。</p>
<p>JVM是字节码格式程序的解释器，一次只执行字节码中的一个指令。JVM和用户提供的程序都能派生额外的线程，所以用户提供的程序中可能同时运行着多个不同的函数。</p>
<p>JVM的目的</p>
<blockquote>
<ul>
<li>包含一个容器，让应用代码运行其中</li>
<li>较之C/C++，提供了一个安全的执行环境</li>
<li>代开发者管理内存</li>
<li>提供了一个跨平台的执行环境</li>
<li>JVM使用运行时信息进行自我管理</li>
</ul>
</blockquote>
<h2 id="Java和JVM简史">Java和JVM简史</h2><ul>
<li>Java 1.0 （1996年）<blockquote>
<p> 这是Java的第一个公开发行版，只包含212个类，分别放在八个包中。Java平台始终关注向后兼容性，所以使用Java 1.0 编写的代码，不用修改或者重新编译，依旧能在新的Java 8中运行。</p>
</blockquote>
</li>
<li>Java 1.1 （1997年）<blockquote>
<p>这一版Java平台是原来的两倍多，并且引入了“内部类”和第一版反射API。</p>
</blockquote>
</li>
<li>Java 1.2 （1998年）<blockquote>
<p>这是Java一个非常重要的版本。这一版Java平台是原先的三倍，并且首次出现了集合API（包括 Set，Map和List）。1.2版增加的新功能过多，SUN不得不把平台重新命名为“Java 2 Platform”。这里的JAVA 2是商标。</p>
</blockquote>
</li>
<li>Java 1.3 （2000年）<blockquote>
<p>这其实是一个维护版本，主要用于修正缺陷，解决稳定性，并提升性能。这一版还引入了HotSpot Java虚拟机。这个虚拟机现在还在使用（不过有大量的修改和改进）。</p>
</blockquote>
</li>
<li>Java 1.4 （2002年）<blockquote>
<p>这也是一个重要的版本，增加了一些重要的功能，例如高性能底层I/O API，处理文本的正则表达式、XML和XSLT库、SSL支持、日志API和加密支持。</p>
</blockquote>
</li>
<li>Java 5 （2004年）<blockquote>
<p>这一版Java的更新幅度很大，对核心语句做了很多改动，引入了泛型、枚举类型、注解、变长参数方法、自动装包和新版for循环。</p>
</blockquote>
</li>
<li>Java 6 （2006年）<blockquote>
<p>这一版也主要是维护和提升性能，引入了编译器API，扩展了注解的用法和试用范围，还提供了绑定，允许脚本语言和Java交互。这一版对JVM和Swing GUI技术进行了缺陷修正和改进。</p>
</blockquote>
</li>
<li>Java 7 （2011年）<blockquote>
<p>这是Oracle公司接管Java后发布的第一个版本，包括语言和平台的对象重要升级。这一版本引入了处理资源的try语句和NIO.2 API，让开发者编写的资源和I/O 处理代码更加安全不易出错。方法句柄API是反射API的替代品，更简单也更安全，而且打开了动态调用（invokedynamic）的大门。</p>
</blockquote>
</li>
<li>Java 8 （2014年）<blockquote>
<p>这是最新版的Java， 变动的幅度是自Java 5以来最大第一次。这一版引入的lambda表达式有望显著提升开发者的效率；集合API也升级了，改用lambda实现，为此，Java的面向对象实现方式也发生了根本性变化。其他重要更新包括：实现运行在JVM中的JavaScript(Nashorn)，新的日期和时间支持，以及Java配置。</p>
</blockquote>
</li>
</ul>
<h2 id="Java的生命周期">Java的生命周期</h2><p>整个流程冲Java的源码开始，经过javac程序处理后得到类文件，这个文件中保存的是编译源码后得到的Java字节码。类文件是Java平台能处理的最小功能单位，也是把新代码传给运行中程序的唯一方式。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2016/03/15/java-environment/" data-id="cilt153wt002rc0tjulh9w1qc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Singleton" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/28/Singleton/" class="article-date">
  <time datetime="2015-12-28T01:52:28.000Z" itemprop="datePublished">2015-12-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/28/Singleton/">Singleton</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="目的">目的</h2><p>确定某个类只有一个实例，并且为之提供一个全局访问点，为了防止其他工作人员实例化我们的类。</p>
<h2 id="方法">方法</h2><p>为该类创建唯一一个构造器，并将构造器设置为私有。不能有有其他非私有构造器，或者根本又有为该类提供构造器，其他人员任然能够实例化我们的类。</p>
<h2 id="java里面通常有两种方法实现">java里面通常有两种方法实现</h2><ul>
<li>饿汉模式： 指全局的单例实例在类装载时构建，急切初始化。</li>
<li>懒汉模式： 指全局的单例实例在第一次被使用时构建，延迟初始化。</li>
</ul>
<h2 id="饿汉模式">饿汉模式</h2><p>采用饿汉模式可以避免线程安全问题，但是任何对Singleton类的访问，比如类中有另外一个static方法被访问，将会引起jvm去初始化instance，而此时我们的本意是不想加载单例类。同时又因为没有延迟加载，最明显的缺点就是如果构造器内的方法比较耗时，则加载过程会比较长。对于一般的应用，构造方法内的代码不涉及到读取配置，远程调用，初始化IOC容器等长时间执行的情况，这种方法最简单。<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line"> <span class="keyword"> private</span><span class="function"> Singleton(</span><span class="function">)</span>&#123;&#125;</span><br><span class="line"> <span class="keyword"> private</span><span class="keyword"> static</span> Singleton<span class="instruction"> instance </span>=<span class="instruction"> new </span>Singleton(<span class="function">)</span>;</span><br><span class="line"> <span class="keyword"> public</span><span class="keyword"> static</span> Singleton<span class="function"> getInstance(</span><span class="function">)</span>&#123;</span><br><span class="line">   <span class="instruction"> return </span>instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="懒汉模式">懒汉模式</h2><p>单线程下没有问题，但多线程情况下可能会出现两个或以上的instance实例的情况。<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line"> <span class="keyword"> private</span><span class="function"> Singleton(</span><span class="function">)</span>&#123;&#125;</span><br><span class="line"> <span class="keyword"> private</span><span class="keyword"> static</span> Singleton<span class="instruction"> instance </span>= null;</span><br><span class="line"> <span class="keyword"> public</span><span class="keyword"> static</span> Singleton<span class="function"> getInstance(</span><span class="function">)</span>&#123;</span><br><span class="line">   <span class="function"> if(</span>instance==null<span class="function">)</span>&#123;</span><br><span class="line">     <span class="instruction"> instance </span>=<span class="instruction"> new </span>Singleton(<span class="function">)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="instruction"> return </span>instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>问题：线程1在判断instance=null为真，执行new 操作之前，判断为真之后，线程2正好执行判断操作，这是instance还是null。因此线程2也会执行new操作。<br>改进代码<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line"> <span class="keyword"> private</span><span class="function"> Singleton(</span><span class="function">)</span>&#123;&#125;</span><br><span class="line"> <span class="keyword"> private</span><span class="keyword"> static</span> Singleton<span class="instruction"> instance </span>= null;</span><br><span class="line"> <span class="keyword"> public</span><span class="keyword"> static</span> synchronized Singleton<span class="function"> getInstance(</span><span class="function">)</span>&#123;</span><br><span class="line">   <span class="function"> if(</span>instance == null<span class="function">)</span>&#123;</span><br><span class="line">     <span class="instruction"> instance </span>=<span class="instruction"> new </span>Singleton(<span class="function">)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="instruction"> return </span>instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getInstance 会被外部线程比较频繁的调用，同步比非同步要消耗更多昂贵的资源，因此这样的做法存在很大的额外性能消耗。因此产生如下双检查写法：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line"> <span class="keyword"> private</span><span class="function"> Singleton(</span><span class="function">)</span>&#123;&#125;</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> Singleton<span class="instruction"> instance </span>= null;</span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> Singleton<span class="function"> getInstance(</span><span class="function">)</span>&#123;</span><br><span class="line">     <span class="function"> if(</span>instance == null<span class="function">)</span>&#123;</span><br><span class="line">       <span class="function"> synchronized(</span>Singleton.class<span class="function">)</span>&#123;</span><br><span class="line">         <span class="function"> if(</span>instance == null<span class="function">)</span>&#123;</span><br><span class="line">           <span class="instruction"> instance </span>==<span class="instruction"> new </span>Singleton(<span class="function">)</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="instruction"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>instance = new Singleton(), 对于编译器来说，分两步走，首先初始化一个instance 对象并随意赋一个值，然后调用Singleton类的构造器赋值。因此在第一步完成之后instance==null这一步已经不成立了,但此时instance只是一个临时值。如果线程2此时进入getInstance,就会把这个instance给返回。<br>可以用一个容器类来解决这个问题。即可以使用延迟加载，让类在被使用的时候才加载，又避免额外的同步调用开销，同时还不使用双检查的模式。<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line"> <span class="keyword"> private</span><span class="keyword"> static</span> class SingletonHolder&#123;</span><br><span class="line">   <span class="keyword"> static</span> Singleton<span class="instruction"> instance </span>=<span class="instruction"> new </span>Singleton(<span class="function">)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword"> public</span><span class="keyword"> static</span> Singleton<span class="function"> getInstance(</span><span class="function">)</span>&#123;</span><br><span class="line">   <span class="instruction"> return </span>SingletonHolder.instance;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword"> private</span><span class="function"> Signleton(</span><span class="function">)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>java中，只有一个类被用到的时候才被初始化。在getInstance方法被调用的时候，如果SingletonHolder类没有被加载，就会去加载，起到延迟加载的作用，同时也能保持多线程下的语义正确性。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/12/28/Singleton/" data-id="cilt153y9004qc0tjjk0i9kcm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-Singleton/">Java-Singleton</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-check-linux-version" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/18/check-linux-version/" class="article-date">
  <time datetime="2015-12-18T04:03:14.000Z" itemprop="datePublished">2015-12-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/18/check-linux-version/">check-linux-version</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="电脑以及操作系统的相关信息">电脑以及操作系统的相关信息</h3><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -<span class="literal">a</span></span><br></pre></td></tr></table></figure>
<h3 id="正在运行的内核版本">正在运行的内核版本</h3><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /<span class="keyword">proc</span>/version</span><br></pre></td></tr></table></figure>
<h3 id="显示发行版本信息">显示发行版本信息</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/etc/i</span>ssue</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/12/18/check-linux-version/" data-id="cilt153xm003qc0tjnuljqpbf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-NIO-Programing" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/10/NIO-Programing/" class="article-date">
  <time datetime="2015-12-10T02:57:35.000Z" itemprop="datePublished">2015-12-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/10/NIO-Programing/">NIO-Programing</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="NIO_开发步骤">NIO 开发步骤</h2><ul>
<li>创建ServerSocketChannel，配置他为非阻塞模式；</li>
<li>绑定监听，配置TCP参数，backlog的大小；</li>
<li>创建一个独立的I/O线程，用于轮询多路复用器Selector；</li>
<li>创建Selector，将之前创建的ServerSocketChannel 注册到Selector上，监听SelectorKey.ACCEPT;</li>
<li>启动I/O线程，在循环体中执行Selector。select()方法，轮询就绪的Channel；</li>
<li>当轮询到就绪状态的Channel时，需要进行判断，如果是OP_ACCEPT状态，说明是新接入的客户端，则调用ServerSocketChannel.accept()方法接受新的客户端；</li>
<li>设置新接入的客户端链路SocketChannel为非阻塞模式，配置其他的一些TCP参数；</li>
<li>将SocketChannel注册到Selector，监听OP_READ操作位；</li>
<li>如果轮询的Channel为OP_READ，则说明SocketChannel中有就绪的数据包需要读取，则构造ByteBuffer对象，读入数据包；</li>
<li>如果轮询的Channel为OP_WRITE，说明还有数据没有发送完成，需要继续发送。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/12/10/NIO-Programing/" data-id="cilt153yt005qc0tjnlh2xv8c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NIO/">NIO</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JAVA-NIO-Netty" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/09/JAVA-NIO-Netty/" class="article-date">
  <time datetime="2015-12-09T08:32:04.000Z" itemprop="datePublished">2015-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/09/JAVA-NIO-Netty/">JAVA-NIO-Netty</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Java_NIO_问题">Java NIO 问题</h2><ul>
<li><p>NIO 的类库和API繁琐，使用麻烦，需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。</p>
</li>
<li><p>需要具备其他的额外技能做铺垫，例如熟悉Java多线程编程。因为NIO编程涉及到Reactor模式。</p>
</li>
<li><p>可靠性能力补齐、工作量大、难度大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理能力等问题。</p>
</li>
<li><p>JDK NIO的BUG。例如epoll bug。它会导致Selector空轮询，最终导致CPU 100%。</p>
</li>
</ul>
<h2 id="Netty">Netty</h2><ul>
<li><p>API 简单，开发门槛低；</p>
</li>
<li><p>功能强大，预设置了多种编码能力，支持多种主流协议；</p>
</li>
<li><p>定制能力强，可以通过ChannelHandler对通信框架进行灵活地扩展；</p>
</li>
<li><p>性能高，通过与其他业界主流的NIO框架对比，Netty的综合能力最优；</p>
</li>
<li><p>成熟、稳定、Netty修复了已经发现的所有JDK NIO BUG，业务人员不需要再为NIO 的BUG烦恼；</p>
</li>
<li><p>社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更新的新功能会加入；</p>
</li>
<li><p>经历了大规模的商业应用考验，质量得到保证。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/12/09/JAVA-NIO-Netty/" data-id="cilt153z1005yc0tjrf76wpw6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NIO/">NIO</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-IO-Contrast" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/03/IO-Contrast/" class="article-date">
  <time datetime="2015-12-03T09:37:25.000Z" itemprop="datePublished">2015-12-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/03/IO-Contrast/">IO-Contrast</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="4中I/O对比">4中I/O对比</h2><h3 id="异步非阻塞I/O">异步非阻塞I/O</h3><p>在早期JDK1.4 和 1.5 Update10版本之前，JDK的Selector基于select/poll模型实现，它是基于I/O复用技术的非阻塞I/O，不是异步I/O。在JDK1.5 Update 10 和 Linux core 2.6 以上版本，Sun优化了Selector实现，它在底层使用epoll替换了selector/poll，上层的API没有变化。<br>由于 JDK1.7 提供的NIO2.0,新增了异步套接字通道，它是真正的异步I/O，在异步I/O操作的时候可以传递信号变量，当操作完成后悔调用相关的方法，异步I/O被称为AIO。<br>NIO类库支持非阻塞读和写，相比于之前的同步阻塞读和写，它是异步的，因此习惯称NIO为异步非阻塞I/O。</p>
<h3 id="多路复用器Selector">多路复用器Selector</h3><p>JAVA NIO的实现关键是多路复用I/O技术，多路复用的核心就是通过Selector轮询注册在其上Channel，当发现某个或者多个Channel处于就绪状态后，从阻塞状态返回就绪的Channel的选择键集合，进行I/O操作。由于多路复用器是NIO实现非阻塞IO的关键，它又是主要通过Selector实现的。</p>
<h3 id="伪异步I/O">伪异步I/O</h3><p>伪异步I/O的概念来源于实践，在JDK NIO编程没有流行之前，为了解决Tomcat通信线程同步I/O导致业务线程被挂住的问题，大家想了一个方法：在通信线程和业务线程之间做一个缓冲区，这个缓冲区用于隔离I/O线程和业务线程间的直接访问，这样业务线程就不会被I/O线程阻塞。对于后端业务来说，将消息或者Task放到线程池后就返回了，它不再直接访问I/O线程或进行I/O读写，这样就不会被同步阻塞。类似的设计还包含前端启动一组线程，将接收的客户端封装成Task，放到后端的线程池执行，用于解决一连接一线程的问题。</p>
<h2 id="不同I/O模型对比">不同I/O模型对比</h2><p>表 1 几种I/O模型的功能和特性对比<br>| 模型 | 同步阻塞I/O（BIO） | 伪异步I/O | 非阻塞I/O（NIO） | 异步I/O（AIO）|<br>| :—– | :—- | :—- | :—- | :—- |<br>| 客户端个数：I/O线程 | 1：1  | M:N（其中M可以大于N） | M:1（1个I/O线程处理多个客户端连接） | M:0（不需要启动额外线程，被动调用） |<br>| I/O类型（阻塞） | 阻塞I/O   | 阻塞I/O | 非阻塞I/O | 非阻塞I/O |<br>| I/O类型（同步） | 同步I/O   | 同步I/O | 同步I/O（I/O多路复用）| 异步I/O |<br>| API使用难度 | 简单  | 简单 | 非常复杂 | 复杂 |<br>| 调度难度 | 简单 | 简单 | 复杂 | 复杂|<br>| 可靠性 | 非常差 | 差 | 高 | 高 |<br>| 吞吐量 | 低 | 中 | 高 | 高|</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/12/03/IO-Contrast/" data-id="cilt153z40060c0tjw4flbmvg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NIO/">NIO</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-AIO" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/03/AIO/" class="article-date">
  <time datetime="2015-12-03T01:50:20.000Z" itemprop="datePublished">2015-12-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/03/AIO/">AIO</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="AIO_Programing">AIO Programing</h2><p>NIO 2.0 引入了新的异步通道的概念，并提拱了异步文件通道和异步套接字通道的实现。异步通道通过两种方式获取操作结果。</p>
<ul>
<li>通过java.util.concurrent.Future类来表示异步操作的结果。</li>
<li>在执行异步操作的时候传入一个java.nio.channel。<br>CompletionHandler 接口的实现类作为操作完成的回调。<br>NIO 2.0 的异步套接字通道是真正的异步非阻塞I/O，它对应UNIX网络编程中的时间驱动I/O（AIO），他不需要通过多路复用器Selector对应注册的通道进行轮询操作即可以实现异步读写。</li>
</ul>
<p><a href="https://github.com/zhaohuizhang/java-nio-demo" target="_blank" rel="external">Github</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/12/03/AIO/" data-id="cilt153zm006yc0tjtldfk22i" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NIO/">NIO</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-NIO-library" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/02/NIO-library/" class="article-date">
  <time datetime="2015-12-02T05:15:50.000Z" itemprop="datePublished">2015-12-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/02/NIO-library/">NIO-library</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="NIO_类库简介">NIO 类库简介</h2><h3 id="缓冲区Buffer">缓冲区Buffer</h3><p>Buffer是一个对象，它包含一些要读出或写入的数据。在NIO库中，所有数据都是用缓冲区处理的。任何时候访问数据都是通过缓冲区进行的。</p>
<p>缓冲区实质上是一个数组。通常它是一个字节数组（ByteBuffer），也可以使用其他种类的数组。</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer<br>每一个Buffer类都是Buffer接口的子实例。除了ByteBuffer，每一个Buffer类都有完全一样的操作。</li>
</ul>
<h3 id="通道Channel">通道Channel</h3><p>Channel是一个通道，可以通过它读取和写入数据。通道与流不同之处在于通道是双向的，流只是在一个方向上移动（一个流必须是InputStream或者是OutputStream的子类）。</p>
<p>因为通道是全双工的，所以它可以更好的映射操作系统底层的API。特别是UNIX网络编程模型中，底层操作系统通道都是全双工的。从类图上看Channel可以分为两大类；分别是用于网络读写的SelectableChannel和用于文件操作的FileChannel。</p>
<p>SocketChannel和ServerSocketChannel都是SelectableChannel的子类。</p>
<h3 id="多路复用器Selector">多路复用器Selector</h3><p>多路复用器提供已经就绪的任务的能力。简单的讲Selector不断轮询注册在其上的Channel，如果某个Channel上面有新的TCP接入、读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续I/O操作。</p>
<p>一个多路复用器Selector可以轮询多个Channel，由于JDK采用epoll()代替传统的select实现，所以它并没有最大连接句柄的限制。</p>
<h2 id="NIO服务器主要创建过程">NIO服务器主要创建过程</h2><ul>
<li><p>打开ServerSocketChannel，用于监听客户端请求连接，它是所有客户端连接的父管道</p>
<figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocketChannel</span> acceptorSvr = <span class="type">ServerSocketChannel</span>.<span class="keyword">open</span><span class="literal">()</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定监听端口，设置连接为非阻塞模式</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">acceptorSvr</span><span class="class">.socket</span>()<span class="class">.bind</span>(<span class="tag">new</span> <span class="tag">InetSocketAddress</span>(<span class="tag">InetAddress</span><span class="class">.getByName</span>("<span class="tag">IP</span>"),<span class="tag">port</span>));</span><br><span class="line"><span class="tag">acceptorSvr</span><span class="class">.configureBlocking</span>(<span class="tag">false</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建Reactor线程，创建多路复用器并启动线程</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Selet<span class="subst">or</span> <span class="keyword">select</span><span class="subst">or</span> = <span class="keyword">Select</span><span class="subst">or</span><span class="built_in">.</span>open();</span><br><span class="line"><span class="literal">New</span> Tread(<span class="literal">new</span> ReactorTask())<span class="built_in">.</span>start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>将ServerSocketChannel注册到Reactor线程的多路复用器Selector上，监听ACCEPT事件</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SelectionKey </span>key = acceptorSvr.register(<span class="keyword">selector, </span><span class="keyword">SelectionKey.OP_ACCEPT,ioHandler);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多路复用器在线程run方法的无限循环体内轮询准备就绪的Key</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = selector.select();</span><br><span class="line"><span class="type">Set</span> selectedKeys = selector.selectedKeys();</span><br><span class="line"><span class="type">Iterator</span> it = selectedKeys.<span class="keyword">iterator</span>();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">  <span class="type">SelectionKey</span> key = (<span class="type">SelectionKey</span>) it.next();</span><br><span class="line">  //<span class="type">TODO</span> deal <span class="keyword">with</span> I/O event</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多路复用器监听到所有新的客户端接入，处理新的接入请求，完成TCP三次握手，建立物理链路</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel channel = svrChannel.accept()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置客户端链路为非阻塞模式</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">channel</span><span class="class">.configureBlocking</span>(<span class="tag">false</span>);</span><br><span class="line"><span class="tag">channel</span><span class="class">.socket</span>()<span class="class">.setReuseAddress</span>(<span class="tag">true</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>将新的客户端连接注册到Reactor线程的多路复用器上，监听读操作，用来读取客户端发送的网络消息</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SelectionKey </span>key = socketChannel.register(<span class="keyword">selector, </span><span class="keyword">SelectionKey.OP_READ, </span>ioHandler)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>异步读取客户端请求消息到缓冲区</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readNumber = channel.<span class="keyword">read</span>(receivedBuffer);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对ByteBuffer进行编解码，如果有半包指针reset,继续读取后续的报文，将解码成功的消息封装成Task，投递到业务线程池中，进行业务逻辑的编排</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Object</span> message = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemain())&#123;</span><br><span class="line">  byteBuffer.mark();</span><br><span class="line">  <span class="keyword">Object</span> message = decode(ByteBuffer);</span><br><span class="line">  <span class="keyword">if</span>(message == <span class="keyword">null</span>)&#123;</span><br><span class="line">    byteBuffer.reset();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  messageList.<span class="built_in">add</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!byteBuffer.hasRemain())&#123;</span><br><span class="line">  byteBuffer.<span class="built_in">clear</span>();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  byteBuffer.compact();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(messageList != <span class="keyword">null</span> &amp; !messageList.isEmpty())&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">Object</span> messageE : messageList)&#123;</span><br><span class="line">    handlerTask(messageE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将POJO对象encode成ByteBuffer，调用SocketChannel的异步write接口，将消息异步发送给客户端</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.<span class="keyword">write</span>(<span class="keyword">buffer</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="NIO_客户端创建">NIO 客户端创建</h2><ul>
<li><p>打开SocketChannel，绑定客户端本地地址</p>
<figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> clientChannel = <span class="type">SocketChannel</span>.<span class="keyword">open</span><span class="literal">()</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置SocketChannel为非阻塞模式，同时设置客户端连接的TCP参数</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">clientChannel</span><span class="class">.configureBlocking</span>(<span class="tag">false</span>);</span><br><span class="line"><span class="tag">socket</span><span class="class">.setReuseAddress</span>(<span class="tag">true</span>);</span><br><span class="line"><span class="tag">socket</span><span class="class">.setReceiveBufferSize</span>(<span class="tag">BUFFER_SIZE</span>);</span><br><span class="line"><span class="tag">socket</span><span class="class">.setSendBufferSize</span>(<span class="tag">BUFFER_SIZE</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>异步连接服务器</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="typename">boolean</span> connectioned = clientChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"IP"</span>).<span class="keyword">port</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断连接是否成功，如果连接成功，则直接注册读状态位到多路复用器中，如果当前没有连接成功（异步连接，返回false，说明客户端已经发送sync包，服务端没有返回ack包，物理链路没有建立）</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">if</span>(connectioned)&#123;</span><br><span class="line">  clientChannel.register(<span class="keyword">selector, </span><span class="keyword">SelectorKey.OP_READ, </span>ioHandler)<span class="comment">;</span></span><br><span class="line">&#125;<span class="preprocessor">else</span>&#123;</span><br><span class="line">  clientChannel.register(<span class="keyword">selector, </span><span class="keyword">SelectorKey.OP_CONNECT,ioHandler);</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>向Reactor线程的多路复用器注册OP_CONNECT状态位，监听服务端的TCP ACK应答</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">clientChannel.register</span>(<span class="keyword">selector, </span><span class="keyword">SelectorKey.OP_CONNECT, </span>ioHandler)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建Reactor线程，创建多路复用器并启动线程</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span><span class="subst">or</span> <span class="keyword">select</span><span class="subst">or</span> = <span class="keyword">Select</span><span class="subst">or</span><span class="built_in">.</span>open();</span><br><span class="line"><span class="literal">New</span> <span class="keyword">Thread</span>(<span class="literal">new</span> ReactorTask())<span class="built_in">.</span>start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>多路复用器在线程run方法的无限循环内轮询准备就绪的Key</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = selector.select();</span><br><span class="line"><span class="type">Set</span> selectedKeys = selector.selectedKeys();</span><br><span class="line"><span class="type">Iterator</span> it = selectedKeys.<span class="keyword">iterator</span>();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">  <span class="type">SelectionKey</span> key= (<span class="type">SelectionKey</span>) it.next();</span><br><span class="line">  // <span class="type">TODO</span> deal <span class="keyword">with</span> I/O event</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接收connect事件进行处理</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span><span class="comment">(key.isConnectable()</span>)&#123;</span><br><span class="line">  <span class="comment">//handlerConnect();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断连接结果，如果连接成功，注册读事件到多路复用器</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span><span class="comment">(channel.finishConnect()</span>)&#123;</span><br><span class="line">  registerRead<span class="comment">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册事件到多路复用器</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">clientChannel</span><span class="class">.register</span>(<span class="tag">selector</span>, <span class="tag">SelectionKey</span><span class="class">.OP_READ</span>,<span class="tag">ioHandler</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>异步读取客户端请求消息到缓冲区</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readNumber = channel.<span class="keyword">read</span>(recevicedBuffer);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对ByteBuffer进行编解码，如果有半包消息接收缓冲区Reset，继续读取后续的报文，将解码成功的消息封装成Task，投递到业务线程池中</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Object</span> message = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemain)&#123;</span><br><span class="line">  byteBuffer.mark();</span><br><span class="line">  <span class="keyword">Object</span> message = decode(byteBuffer);</span><br><span class="line">  <span class="keyword">if</span>(message == <span class="keyword">null</span>)&#123;</span><br><span class="line">    byteBuffer.reset();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  messageList.<span class="built_in">add</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!byteBuffer.hasRemain())&#123;</span><br><span class="line">  byteBuffer.<span class="built_in">clear</span>();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  byteBuffer.compact();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(messageList != <span class="keyword">null</span> &amp;&amp; !messageList.isEmpty())&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">Object</span> messageE : messageList)&#123;</span><br><span class="line">    handlerTask(messageE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将POJO对象encode成ByteBuffer，调用SocketChannel的异步write接口，将消息异步发送给客户端</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.<span class="keyword">write</span>(<span class="keyword">buffer</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="NIO_编程的优点">NIO 编程的优点</h3><ul>
<li>客户端连接都是异步的，可以通过多路复用器注册OP_CONNECT等待后续结果，不需要像之前的客户端那样被同步阻塞。</li>
<li>SocketChannel的读写操作都是异步的，如果没有可读写的数据，它不会同步等待,直接返回，这样I/O通信线程可以处理其他的链路，不需要同步等待这个链路可用。</li>
<li>线程模型的优化，由于JDK的Selector在Linux等主流操作系统上通过epoll实现，它没有连接句柄数的限制，这就意味着一个Selector可以处理成千上万的客户端连接，而且性能不会随着客户端的增加而下降。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/12/02/NIO-library/" data-id="cilt153yq005nc0tju2kopxp5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NIO/">NIO</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-NIO-Introduce-Abstractly" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/30/NIO-Introduce-Abstractly/" class="article-date">
  <time datetime="2015-11-30T07:07:51.000Z" itemprop="datePublished">2015-11-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/30/NIO-Introduce-Abstractly/">NIO-Introduce-Abstractly</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="NIO_入门">NIO 入门</h1><h2 id="传统的BIO编程">传统的BIO编程</h2><p>网络编程的基本模型是Client/Server模型，也就是两个进程之间进行相互通信，其中服务端提供位置信息，客户端通过连接操作向服务器端监听的地址发送连接请求，通过三次握手简历连接，如果连接简历成功，双发就可以通过网络套接字（Socket）进行通信。</p>
<p>在基于传统同步阻塞模型开发中，ServerSocket负责绑定IP地址，启动监听端口；Socket负责发起连接操作。连接成功之后，双发通过输入输出流进行同步阻塞式通信。</p>
<p>在传统的BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成之后，通过输出流返回应答给客户端，线程销毁。最大的缺点是，当客户端访问量增大之后，服务端的线程个数和客户端的并发访问量呈1：1 的正比关系，由于线程是Java虚拟机非常宝贵的系统资源，当线程膨胀之后，系统的性能将急剧下降，系统会出现线程堆栈溢出、创建线程失败等问题。</p>
<p>为了改进一线程一连接模型，后来又演进出了一种通过线程池或者消息队列实现1个或者多个线程处理N个客户端的模型，由于它的底层通信机制依然使用同步阻塞I/O，所以被称为“伪异步”。</p>
<h2 id="伪异步I/O编程">伪异步I/O编程</h2><p>后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数M：线程池最大线程数N的比例关系，其中M远大于N，通过线程池可以灵活调配线程资源，设置线程最大值，防止海量并发接入导致线程耗尽。</p>
<p>当有新的客户端接入的时候，将客户端的Socket封装成一个Task投递到后端线程池中进行处理，JDK的线程池维护一个消息队列和N个活跃线程对消息队列中的消息进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少客户端并发访问，都不会导致资源的耗尽和宕机。</p>
<p>伪异步I/O通信框架采用了线程池实现，因此避免了为每个请求都创建一个独立线程造成的线程资源耗尽的问题。但是它底层通信仍采用同步阻塞模型，因此无法从根本上解决问题。</p>
<p>Java输入流 InputStream<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">return</span> <span class="title">read</span><span class="params">(b, <span class="number">0</span>, b.length)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当对Socket输入流进行读取时，操作一直会阻塞下去，直到发生如下几件事情：</p>
<ul>
<li>有数据可读；</li>
<li>可用数据以读取完毕；</li>
<li>发生空指针或者I/O异常。</li>
</ul>
<p>当对方发送消息或者应答消息比较缓慢、或者网络传输较慢时，读取输入流一方的通信线程将长时间阻塞。</p>
<p>Java输出流 OutputStream<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">write</span>(<span class="keyword">byte</span> b[]) <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure></p>
<p>当调用OutputStream 的write方法时，它将会被阻塞，直到所有要发送的字节全部写入完毕，或者发生异常。</p>
<p>通过分析输入和输出流的API文档，我们发现读和写操作都是同步阻塞的，阻塞时间取决于对方的I/O线程处理速度和网络I/O的传播速度。</p>
<h2 id="Non_block_I/O">Non block I/O</h2><p>与Socket和SocketServer类相对应，NIO 也提供的SocketChannel和ServerSocketChannel两种不同的套接字通道实现.这两种新增的通道都支持阻塞和非阻塞两种模式。阻塞模式使用非常简单，但是性能和可靠性都不好。<br>非阻塞模式恰好相反。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/11/30/NIO-Introduce-Abstractly/" data-id="cilt153yu005sc0tji5u1cacq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NIO/">NIO</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-I-O-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/30/java-I-O-2/" class="article-date">
  <time datetime="2015-11-30T06:17:03.000Z" itemprop="datePublished">2015-11-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/30/java-I-O-2/">java-I/O-2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-2_Java_的_I/O演进(2)">1.2 Java 的 I/O演进(2)</h2><p>在JDK1.4退出JavaNIO 之前，基于Java的所有Socket通信都采用了同步阻塞模式（BIO），这种一请求一应答的通信模型简化了上层的阴功开发，但是在性能和可靠性方面却存在着巨大的瓶颈。因此，在很长一段时间里，大型的应用服务器都采用C或者C++语言开发，因为他们可以直接使用操作系统提供的异步I/O或者AIO能力。当并发访问量增大、响应时间延迟增大之后，采用Java BIO开发的服务端软件只能通过硬件的不断扩容来满足高并发和低延迟。</p>
<p>正是由于Java传统BIO的劣势，才使得Java支持非阻塞I/O的呼声渐高，最终JDK1.4版本中提供了新的NIO类库。</p>
<h3 id="Java的I/O简史">Java的I/O简史</h3><p>2002年发布的JDK1.4时，NIO以JSR-51的身份正是随着JDK发布。它增加了java.nio包，提供了很多进行异步I/O开发的API和类库，主要的接口如下：</p>
<ul>
<li>进行异步I/O操作的缓冲区ByteBuffer；</li>
<li>进行异步I/O操作的管道Pipe；</li>
<li>进行各种I/O操作（异步或同步）的Channel，包括ServerSocketChannel和SocketChannel；</li>
<li>多种字符集的编码能力和解码能力；</li>
<li>实现非阻塞I/O操作的多路复用器Selector；</li>
<li>基于流行了Perl实现正则表达式类库；</li>
<li>文件通道FileChannel。</li>
</ul>
<p>新的NIO类库的提供，极大地促进了基于Java的异步非阻塞编程的发展和应用，但是，它依然有不完善的地方，特别是对文件系统的处理能力仍显不足，主要问题如下：</p>
<ul>
<li>没有统一的文件属性；</li>
<li>API能力比较弱，例如目录的级联创建和递归遍历，往往需要自己实现；</li>
<li>底层存储系统的一些高级API无法使用；</li>
<li>所有的文件操作都是同步阻塞调用，不支持异步文件读写操作。</li>
</ul>
<p>2011年7月28日，JDK1.7 正是发布。它的一个比较大亮点就是将原来的NIO类库进行了升级，被称为NIO2.0，有JSR-203演进而来，它主要提供了如下三个方面的改进。</p>
<ul>
<li>提供能够批量获取文件属性的API，这些API具有平台无关性，不与特性的文件系统耦合，另外它还提供了标准文件系统的SPI，供各个服务提供商扩展实现；</li>
<li>提供AIO功能，支持基于文件的异步I/O操作和针对网络套接字的异步操作；</li>
<li>完成JSR-51 定义的通道功能，包括对配置和多播数据包的支持等。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/11/30/java-I-O-2/" data-id="cilt153wy002xc0tjn6l7ulhg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaIO/">JavaIO</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Flask/">Flask</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hibernate/">Hibernate</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Struts/">Struts</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/fibonacci/">fibonacci</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/socket/">socket</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Abstract/">Abstract</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bloom-Filter/">Bloom Filter</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Classpath/">Classpath</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collections/">Collections</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Configuration/">Configuration</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DTD/">DTD</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Deadlock/">Deadlock</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Duplicate-from-Array/">Duplicate from Array</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Exception/">Exception</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flask-migrate/">Flask migrate</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HQL/">HQL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hashmap/">Hashmap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hibernate/">Hibernate</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Interface/">Interface</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-Singleton/">Java-Singleton</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaIO/">JavaIO</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Login/">Login</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVC/">MVC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NIO/">NIO</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OOP/">OOP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ORM/">ORM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Path/">Path</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/QBC/">QBC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Query/">Query</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SVN/">SVN</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Schema/">Schema</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scrapy/">Scrapy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Session/">Session</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sublime-Text2-Plugins-install/">Sublime Text2 Plugins install</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tag/">Tag</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tiles/">Tiles</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tokens/">Tokens</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Validation/">Validation</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XML/">XML</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/component/">component</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/concurrent/">concurrent</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/crawler/">crawler</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hashtable/">hashtable</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javaIO/">javaIO</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/">markdown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/">mongodb</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/multiThread/">multiThread</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-yield/">python yield</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-rq/">python-rq</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/srcapy/">srcapy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stored-procedure/">stored procedure</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/struts/">struts</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/study/">study</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/work-principal/">work principal</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中文乱码/">中文乱码</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/全栈工程师/">全栈工程师</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式爬虫/">分布式爬虫</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/对象映射/">对象映射</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据挖掘/">数据挖掘</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文本处理/">文本处理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/机器学习/">机器学习</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/科学计算/">科学计算</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络爬虫/">网络爬虫</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Abstract/" style="font-size: 10px;">Abstract</a> <a href="/tags/Bloom-Filter/" style="font-size: 10px;">Bloom Filter</a> <a href="/tags/Classpath/" style="font-size: 10px;">Classpath</a> <a href="/tags/Collections/" style="font-size: 10px;">Collections</a> <a href="/tags/Configuration/" style="font-size: 10px;">Configuration</a> <a href="/tags/DTD/" style="font-size: 10px;">DTD</a> <a href="/tags/Deadlock/" style="font-size: 10px;">Deadlock</a> <a href="/tags/Duplicate-from-Array/" style="font-size: 10px;">Duplicate from Array</a> <a href="/tags/Exception/" style="font-size: 10px;">Exception</a> <a href="/tags/Flask-migrate/" style="font-size: 10px;">Flask migrate</a> <a href="/tags/HQL/" style="font-size: 10px;">HQL</a> <a href="/tags/Hashmap/" style="font-size: 10px;">Hashmap</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Hibernate/" style="font-size: 16px;">Hibernate</a> <a href="/tags/Interface/" style="font-size: 10px;">Interface</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/Java-Singleton/" style="font-size: 10px;">Java-Singleton</a> <a href="/tags/JavaIO/" style="font-size: 10px;">JavaIO</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Login/" style="font-size: 10px;">Login</a> <a href="/tags/MVC/" style="font-size: 10px;">MVC</a> <a href="/tags/NIO/" style="font-size: 18px;">NIO</a> <a href="/tags/OOP/" style="font-size: 10px;">OOP</a> <a href="/tags/ORM/" style="font-size: 10px;">ORM</a> <a href="/tags/Path/" style="font-size: 10px;">Path</a> <a href="/tags/QBC/" style="font-size: 10px;">QBC</a> <a href="/tags/Query/" style="font-size: 10px;">Query</a> <a href="/tags/SVN/" style="font-size: 10px;">SVN</a> <a href="/tags/Schema/" style="font-size: 10px;">Schema</a> <a href="/tags/Scrapy/" style="font-size: 10px;">Scrapy</a> <a href="/tags/Session/" style="font-size: 10px;">Session</a> <a href="/tags/Sublime-Text2-Plugins-install/" style="font-size: 10px;">Sublime Text2 Plugins install</a> <a href="/tags/Tag/" style="font-size: 10px;">Tag</a> <a href="/tags/Tiles/" style="font-size: 10px;">Tiles</a> <a href="/tags/Tokens/" style="font-size: 10px;">Tokens</a> <a href="/tags/Validation/" style="font-size: 10px;">Validation</a> <a href="/tags/XML/" style="font-size: 10px;">XML</a> <a href="/tags/component/" style="font-size: 10px;">component</a> <a href="/tags/concurrent/" style="font-size: 10px;">concurrent</a> <a href="/tags/crawler/" style="font-size: 10px;">crawler</a> <a href="/tags/hashtable/" style="font-size: 10px;">hashtable</a> <a href="/tags/java/" style="font-size: 14px;">java</a> <a href="/tags/javaIO/" style="font-size: 10px;">javaIO</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/multiThread/" style="font-size: 10px;">multiThread</a> <a href="/tags/python/" style="font-size: 12px;">python</a> <a href="/tags/python-yield/" style="font-size: 10px;">python yield</a> <a href="/tags/python-rq/" style="font-size: 10px;">python-rq</a> <a href="/tags/srcapy/" style="font-size: 10px;">srcapy</a> <a href="/tags/stored-procedure/" style="font-size: 10px;">stored procedure</a> <a href="/tags/struts/" style="font-size: 20px;">struts</a> <a href="/tags/study/" style="font-size: 10px;">study</a> <a href="/tags/work-principal/" style="font-size: 10px;">work principal</a> <a href="/tags/中文乱码/" style="font-size: 10px;">中文乱码</a> <a href="/tags/全栈工程师/" style="font-size: 10px;">全栈工程师</a> <a href="/tags/分布式爬虫/" style="font-size: 10px;">分布式爬虫</a> <a href="/tags/对象映射/" style="font-size: 10px;">对象映射</a> <a href="/tags/数据挖掘/" style="font-size: 10px;">数据挖掘</a> <a href="/tags/文本处理/" style="font-size: 10px;">文本处理</a> <a href="/tags/机器学习/" style="font-size: 10px;">机器学习</a> <a href="/tags/科学计算/" style="font-size: 10px;">科学计算</a> <a href="/tags/网络爬虫/" style="font-size: 12px;">网络爬虫</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a><span class="archive-list-count">18</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a><span class="archive-list-count">15</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/03/15/java-environment/">java-environment</a>
          </li>
        
          <li>
            <a href="/2015/12/28/Singleton/">Singleton</a>
          </li>
        
          <li>
            <a href="/2015/12/18/check-linux-version/">check-linux-version</a>
          </li>
        
          <li>
            <a href="/2015/12/10/NIO-Programing/">NIO-Programing</a>
          </li>
        
          <li>
            <a href="/2015/12/09/JAVA-NIO-Netty/">JAVA-NIO-Netty</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Zhaohui zhang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>