<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Welcome To Napu&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="This is zhaohuizhang&apos;s blog site">
<meta property="og:type" content="website">
<meta property="og:title" content="Welcome To Napu's Blog">
<meta property="og:url" content="http://zhaohuizhang.github.io/index.html">
<meta property="og:site_name" content="Welcome To Napu's Blog">
<meta property="og:description" content="This is zhaohuizhang&apos;s blog site">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Welcome To Napu's Blog">
<meta name="twitter:description" content="This is zhaohuizhang&apos;s blog site">
  
    <link rel="alternative" href="/atom.xml" title="Welcome To Napu&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Welcome To Napu&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hello world，have a nice day!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://zhaohuizhang.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-NIO-Programing" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/10/NIO-Programing/" class="article-date">
  <time datetime="2015-12-10T02:57:35.000Z" itemprop="datePublished">2015-12-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/10/NIO-Programing/">NIO-Programing</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="NIO_开发步骤">NIO 开发步骤</h2><ul>
<li>创建ServerSocketChannel，配置他为非阻塞模式；</li>
<li>绑定监听，配置TCP参数，backlog的大小；</li>
<li>创建一个独立的I/O线程，用于轮询多路复用器Selector；</li>
<li>创建Selector，将之前创建的ServerSocketChannel 注册到Selector上，监听SelectorKey.ACCEPT;</li>
<li>启动I/O线程，在循环体中执行Selector。select()方法，轮询就绪的Channel；</li>
<li>当轮询到就绪状态的Channel时，需要进行判断，如果是OP_ACCEPT状态，说明是新接入的客户端，则调用ServerSocketChannel.accept()方法接受新的客户端；</li>
<li>设置新接入的客户端链路SocketChannel为非阻塞模式，配置其他的一些TCP参数；</li>
<li>将SocketChannel注册到Selector，监听OP_READ操作位；</li>
<li>如果轮询的Channel为OP_READ，则说明SocketChannel中有就绪的数据包需要读取，则构造ByteBuffer对象，读入数据包；</li>
<li>如果轮询的Channel为OP_WRITE，说明还有数据没有发送完成，需要继续发送。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/12/10/NIO-Programing/" data-id="cii02kkdz005hjktj85h6zeij" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NIO/">NIO</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JAVA-NIO-Netty" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/09/JAVA-NIO-Netty/" class="article-date">
  <time datetime="2015-12-09T08:32:04.000Z" itemprop="datePublished">2015-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/09/JAVA-NIO-Netty/">JAVA-NIO-Netty</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Java_NIO_问题">Java NIO 问题</h2><ul>
<li><p>NIO 的类库和API繁琐，使用麻烦，需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。</p>
</li>
<li><p>需要具备其他的额外技能做铺垫，例如熟悉Java多线程编程。因为NIO编程涉及到Reactor模式。</p>
</li>
<li><p>可靠性能力补齐、工作量大、难度大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理能力等问题。</p>
</li>
<li><p>JDK NIO的BUG。例如epoll bug。它会导致Selector空轮询，最终导致CPU 100%。</p>
</li>
</ul>
<h2 id="Netty">Netty</h2><ul>
<li><p>API 简单，开发门槛低；</p>
</li>
<li><p>功能强大，预设置了多种编码能力，支持多种主流协议；</p>
</li>
<li><p>定制能力强，可以通过ChannelHandler对通信框架进行灵活地扩展；</p>
</li>
<li><p>性能高，通过与其他业界主流的NIO框架对比，Netty的综合能力最优；</p>
</li>
<li><p>成熟、稳定、Netty修复了已经发现的所有JDK NIO BUG，业务人员不需要再为NIO 的BUG烦恼；</p>
</li>
<li><p>社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更新的新功能会加入；</p>
</li>
<li><p>经历了大规模的商业应用考验，质量得到保证。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/12/09/JAVA-NIO-Netty/" data-id="cii02kke8005pjktj600c3cc7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NIO/">NIO</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-IO-Contrast" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/03/IO-Contrast/" class="article-date">
  <time datetime="2015-12-03T09:37:25.000Z" itemprop="datePublished">2015-12-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/03/IO-Contrast/">IO-Contrast</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="4中I/O对比">4中I/O对比</h2><h3 id="异步非阻塞I/O">异步非阻塞I/O</h3><p>在早期JDK1.4 和 1.5 Update10版本之前，JDK的Selector基于select/poll模型实现，它是基于I/O复用技术的非阻塞I/O，不是异步I/O。在JDK1.5 Update 10 和 Linux core 2.6 以上版本，Sun优化了Selector实现，它在底层使用epoll替换了selector/poll，上层的API没有变化。<br>由于 JDK1.7 提供的NIO2.0,新增了异步套接字通道，它是真正的异步I/O，在异步I/O操作的时候可以传递信号变量，当操作完成后悔调用相关的方法，异步I/O被称为AIO。<br>NIO类库支持非阻塞读和写，相比于之前的同步阻塞读和写，它是异步的，因此习惯称NIO为异步非阻塞I/O。</p>
<h3 id="多路复用器Selector">多路复用器Selector</h3><p>JAVA NIO的实现关键是多路复用I/O技术，多路复用的核心就是通过Selector轮询注册在其上Channel，当发现某个或者多个Channel处于就绪状态后，从阻塞状态返回就绪的Channel的选择键集合，进行I/O操作。由于多路复用器是NIO实现非阻塞IO的关键，它又是主要通过Selector实现的。</p>
<h3 id="伪异步I/O">伪异步I/O</h3><p>伪异步I/O的概念来源于实践，在JDK NIO编程没有流行之前，为了解决Tomcat通信线程同步I/O导致业务线程被挂住的问题，大家想了一个方法：在通信线程和业务线程之间做一个缓冲区，这个缓冲区用于隔离I/O线程和业务线程间的直接访问，这样业务线程就不会被I/O线程阻塞。对于后端业务来说，将消息或者Task放到线程池后就返回了，它不再直接访问I/O线程或进行I/O读写，这样就不会被同步阻塞。类似的设计还包含前端启动一组线程，将接收的客户端封装成Task，放到后端的线程池执行，用于解决一连接一线程的问题。</p>
<h2 id="不同I/O模型对比">不同I/O模型对比</h2><p>表 1 几种I/O模型的功能和特性对比<br>| 模型 | 同步阻塞I/O（BIO） | 伪异步I/O | 非阻塞I/O（NIO） | 异步I/O（AIO）|<br>| :—– | :—- | :—- | :—- | :—- |<br>| 客户端个数：I/O线程 | 1：1  | M:N（其中M可以大于N） | M:1（1个I/O线程处理多个客户端连接） | M:0（不需要启动额外线程，被动调用） |<br>| I/O类型（阻塞） | 阻塞I/O   | 阻塞I/O | 非阻塞I/O | 非阻塞I/O |<br>| I/O类型（同步） | 同步I/O   | 同步I/O | 同步I/O（I/O多路复用）| 异步I/O |<br>| API使用难度 | 简单  | 简单 | 非常复杂 | 复杂 |<br>| 调度难度 | 简单 | 简单 | 复杂 | 复杂|<br>| 可靠性 | 非常差 | 差 | 高 | 高 |<br>| 吞吐量 | 低 | 中 | 高 | 高|</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/12/03/IO-Contrast/" data-id="cii02kke9005rjktjtqqm5nwh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NIO/">NIO</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-AIO" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/03/AIO/" class="article-date">
  <time datetime="2015-12-03T01:50:20.000Z" itemprop="datePublished">2015-12-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/03/AIO/">AIO</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="AIO_Programing">AIO Programing</h2><p>NIO 2.0 引入了新的异步通道的概念，并提拱了异步文件通道和异步套接字通道的实现。异步通道通过两种方式获取操作结果。</p>
<ul>
<li>通过java.util.concurrent.Future类来表示异步操作的结果。</li>
<li>在执行异步操作的时候传入一个java.nio.channel。<br>CompletionHandler 接口的实现类作为操作完成的回调。<br>NIO 2.0 的异步套接字通道是真正的异步非阻塞I/O，它对应UNIX网络编程中的时间驱动I/O（AIO），他不需要通过多路复用器Selector对应注册的通道进行轮询操作即可以实现异步读写。</li>
</ul>
<p><a href="https://github.com/zhaohuizhang/java-nio-demo" target="_blank" rel="external">Github</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/12/03/AIO/" data-id="cii02kket006pjktj4wk1e7r4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NIO/">NIO</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-NIO-library" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/02/NIO-library/" class="article-date">
  <time datetime="2015-12-02T05:15:50.000Z" itemprop="datePublished">2015-12-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/02/NIO-library/">NIO-library</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="NIO_类库简介">NIO 类库简介</h2><h3 id="缓冲区Buffer">缓冲区Buffer</h3><p>Buffer是一个对象，它包含一些要读出或写入的数据。在NIO库中，所有数据都是用缓冲区处理的。任何时候访问数据都是通过缓冲区进行的。</p>
<p>缓冲区实质上是一个数组。通常它是一个字节数组（ByteBuffer），也可以使用其他种类的数组。</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer<br>每一个Buffer类都是Buffer接口的子实例。除了ByteBuffer，每一个Buffer类都有完全一样的操作。</li>
</ul>
<h3 id="通道Channel">通道Channel</h3><p>Channel是一个通道，可以通过它读取和写入数据。通道与流不同之处在于通道是双向的，流只是在一个方向上移动（一个流必须是InputStream或者是OutputStream的子类）。</p>
<p>因为通道是全双工的，所以它可以更好的映射操作系统底层的API。特别是UNIX网络编程模型中，底层操作系统通道都是全双工的。从类图上看Channel可以分为两大类；分别是用于网络读写的SelectableChannel和用于文件操作的FileChannel。</p>
<p>SocketChannel和ServerSocketChannel都是SelectableChannel的子类。</p>
<h3 id="多路复用器Selector">多路复用器Selector</h3><p>多路复用器提供已经就绪的任务的能力。简单的讲Selector不断轮询注册在其上的Channel，如果某个Channel上面有新的TCP接入、读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续I/O操作。</p>
<p>一个多路复用器Selector可以轮询多个Channel，由于JDK采用epoll()代替传统的select实现，所以它并没有最大连接句柄的限制。</p>
<h2 id="NIO服务器主要创建过程">NIO服务器主要创建过程</h2><ul>
<li><p>打开ServerSocketChannel，用于监听客户端请求连接，它是所有客户端连接的父管道</p>
<figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocketChannel</span> acceptorSvr = <span class="type">ServerSocketChannel</span>.<span class="keyword">open</span><span class="literal">()</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定监听端口，设置连接为非阻塞模式</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">acceptorSvr</span><span class="class">.socket</span>()<span class="class">.bind</span>(<span class="tag">new</span> <span class="tag">InetSocketAddress</span>(<span class="tag">InetAddress</span><span class="class">.getByName</span>("<span class="tag">IP</span>"),<span class="tag">port</span>));</span><br><span class="line"><span class="tag">acceptorSvr</span><span class="class">.configureBlocking</span>(<span class="tag">false</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建Reactor线程，创建多路复用器并启动线程</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Selet<span class="subst">or</span> <span class="keyword">select</span><span class="subst">or</span> = <span class="keyword">Select</span><span class="subst">or</span><span class="built_in">.</span>open();</span><br><span class="line"><span class="literal">New</span> Tread(<span class="literal">new</span> ReactorTask())<span class="built_in">.</span>start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>将ServerSocketChannel注册到Reactor线程的多路复用器Selector上，监听ACCEPT事件</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SelectionKey </span>key = acceptorSvr.register(<span class="keyword">selector, </span><span class="keyword">SelectionKey.OP_ACCEPT,ioHandler);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多路复用器在线程run方法的无限循环体内轮询准备就绪的Key</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = selector.select();</span><br><span class="line"><span class="type">Set</span> selectedKeys = selector.selectedKeys();</span><br><span class="line"><span class="type">Iterator</span> it = selectedKeys.<span class="keyword">iterator</span>();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">  <span class="type">SelectionKey</span> key = (<span class="type">SelectionKey</span>) it.next();</span><br><span class="line">  //<span class="type">TODO</span> deal <span class="keyword">with</span> I/O event</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多路复用器监听到所有新的客户端接入，处理新的接入请求，完成TCP三次握手，建立物理链路</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel channel = svrChannel.accept()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置客户端链路为非阻塞模式</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">channel</span><span class="class">.configureBlocking</span>(<span class="tag">false</span>);</span><br><span class="line"><span class="tag">channel</span><span class="class">.socket</span>()<span class="class">.setReuseAddress</span>(<span class="tag">true</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>将新的客户端连接注册到Reactor线程的多路复用器上，监听读操作，用来读取客户端发送的网络消息</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SelectionKey </span>key = socketChannel.register(<span class="keyword">selector, </span><span class="keyword">SelectionKey.OP_READ, </span>ioHandler)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>异步读取客户端请求消息到缓冲区</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readNumber = channel.<span class="keyword">read</span>(receivedBuffer);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对ByteBuffer进行编解码，如果有半包指针reset,继续读取后续的报文，将解码成功的消息封装成Task，投递到业务线程池中，进行业务逻辑的编排</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Object</span> message = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemain())&#123;</span><br><span class="line">  byteBuffer.mark();</span><br><span class="line">  <span class="keyword">Object</span> message = decode(ByteBuffer);</span><br><span class="line">  <span class="keyword">if</span>(message == <span class="keyword">null</span>)&#123;</span><br><span class="line">    byteBuffer.reset();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  messageList.<span class="built_in">add</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!byteBuffer.hasRemain())&#123;</span><br><span class="line">  byteBuffer.<span class="built_in">clear</span>();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  byteBuffer.compact();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(messageList != <span class="keyword">null</span> &amp; !messageList.isEmpty())&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">Object</span> messageE : messageList)&#123;</span><br><span class="line">    handlerTask(messageE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将POJO对象encode成ByteBuffer，调用SocketChannel的异步write接口，将消息异步发送给客户端</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.<span class="keyword">write</span>(<span class="keyword">buffer</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="NIO_客户端创建">NIO 客户端创建</h2><ul>
<li><p>打开SocketChannel，绑定客户端本地地址</p>
<figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> clientChannel = <span class="type">SocketChannel</span>.<span class="keyword">open</span><span class="literal">()</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置SocketChannel为非阻塞模式，同时设置客户端连接的TCP参数</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">clientChannel</span><span class="class">.configureBlocking</span>(<span class="tag">false</span>);</span><br><span class="line"><span class="tag">socket</span><span class="class">.setReuseAddress</span>(<span class="tag">true</span>);</span><br><span class="line"><span class="tag">socket</span><span class="class">.setReceiveBufferSize</span>(<span class="tag">BUFFER_SIZE</span>);</span><br><span class="line"><span class="tag">socket</span><span class="class">.setSendBufferSize</span>(<span class="tag">BUFFER_SIZE</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>异步连接服务器</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="typename">boolean</span> connectioned = clientChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"IP"</span>).<span class="keyword">port</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断连接是否成功，如果连接成功，则直接注册读状态位到多路复用器中，如果当前没有连接成功（异步连接，返回false，说明客户端已经发送sync包，服务端没有返回ack包，物理链路没有建立）</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">if</span>(connectioned)&#123;</span><br><span class="line">  clientChannel.register(<span class="keyword">selector, </span><span class="keyword">SelectorKey.OP_READ, </span>ioHandler)<span class="comment">;</span></span><br><span class="line">&#125;<span class="preprocessor">else</span>&#123;</span><br><span class="line">  clientChannel.register(<span class="keyword">selector, </span><span class="keyword">SelectorKey.OP_CONNECT,ioHandler);</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>向Reactor线程的多路复用器注册OP_CONNECT状态位，监听服务端的TCP ACK应答</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">clientChannel.register</span>(<span class="keyword">selector, </span><span class="keyword">SelectorKey.OP_CONNECT, </span>ioHandler)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建Reactor线程，创建多路复用器并启动线程</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span><span class="subst">or</span> <span class="keyword">select</span><span class="subst">or</span> = <span class="keyword">Select</span><span class="subst">or</span><span class="built_in">.</span>open();</span><br><span class="line"><span class="literal">New</span> <span class="keyword">Thread</span>(<span class="literal">new</span> ReactorTask())<span class="built_in">.</span>start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>多路复用器在线程run方法的无限循环内轮询准备就绪的Key</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = selector.select();</span><br><span class="line"><span class="type">Set</span> selectedKeys = selector.selectedKeys();</span><br><span class="line"><span class="type">Iterator</span> it = selectedKeys.<span class="keyword">iterator</span>();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">  <span class="type">SelectionKey</span> key= (<span class="type">SelectionKey</span>) it.next();</span><br><span class="line">  // <span class="type">TODO</span> deal <span class="keyword">with</span> I/O event</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接收connect事件进行处理</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span><span class="comment">(key.isConnectable()</span>)&#123;</span><br><span class="line">  <span class="comment">//handlerConnect();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断连接结果，如果连接成功，注册读事件到多路复用器</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span><span class="comment">(channel.finishConnect()</span>)&#123;</span><br><span class="line">  registerRead<span class="comment">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册事件到多路复用器</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">clientChannel</span><span class="class">.register</span>(<span class="tag">selector</span>, <span class="tag">SelectionKey</span><span class="class">.OP_READ</span>,<span class="tag">ioHandler</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>异步读取客户端请求消息到缓冲区</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readNumber = channel.<span class="keyword">read</span>(recevicedBuffer);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对ByteBuffer进行编解码，如果有半包消息接收缓冲区Reset，继续读取后续的报文，将解码成功的消息封装成Task，投递到业务线程池中</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Object</span> message = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemain)&#123;</span><br><span class="line">  byteBuffer.mark();</span><br><span class="line">  <span class="keyword">Object</span> message = decode(byteBuffer);</span><br><span class="line">  <span class="keyword">if</span>(message == <span class="keyword">null</span>)&#123;</span><br><span class="line">    byteBuffer.reset();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  messageList.<span class="built_in">add</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!byteBuffer.hasRemain())&#123;</span><br><span class="line">  byteBuffer.<span class="built_in">clear</span>();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  byteBuffer.compact();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(messageList != <span class="keyword">null</span> &amp;&amp; !messageList.isEmpty())&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">Object</span> messageE : messageList)&#123;</span><br><span class="line">    handlerTask(messageE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将POJO对象encode成ByteBuffer，调用SocketChannel的异步write接口，将消息异步发送给客户端</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.<span class="keyword">write</span>(<span class="keyword">buffer</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="NIO_编程的优点">NIO 编程的优点</h3><ul>
<li>客户端连接都是异步的，可以通过多路复用器注册OP_CONNECT等待后续结果，不需要像之前的客户端那样被同步阻塞。</li>
<li>SocketChannel的读写操作都是异步的，如果没有可读写的数据，它不会同步等待,直接返回，这样I/O通信线程可以处理其他的链路，不需要同步等待这个链路可用。</li>
<li>线程模型的优化，由于JDK的Selector在Linux等主流操作系统上通过epoll实现，它没有连接句柄数的限制，这就意味着一个Selector可以处理成千上万的客户端连接，而且性能不会随着客户端的增加而下降。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/12/02/NIO-library/" data-id="cii02kkdx005ejktjdcyzceqt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NIO/">NIO</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-NIO-Introduce-Abstractly" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/30/NIO-Introduce-Abstractly/" class="article-date">
  <time datetime="2015-11-30T07:07:51.000Z" itemprop="datePublished">2015-11-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/30/NIO-Introduce-Abstractly/">NIO-Introduce-Abstractly</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="NIO_入门">NIO 入门</h1><h2 id="传统的BIO编程">传统的BIO编程</h2><p>网络编程的基本模型是Client/Server模型，也就是两个进程之间进行相互通信，其中服务端提供位置信息，客户端通过连接操作向服务器端监听的地址发送连接请求，通过三次握手简历连接，如果连接简历成功，双发就可以通过网络套接字（Socket）进行通信。</p>
<p>在基于传统同步阻塞模型开发中，ServerSocket负责绑定IP地址，启动监听端口；Socket负责发起连接操作。连接成功之后，双发通过输入输出流进行同步阻塞式通信。</p>
<p>在传统的BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成之后，通过输出流返回应答给客户端，线程销毁。最大的缺点是，当客户端访问量增大之后，服务端的线程个数和客户端的并发访问量呈1：1 的正比关系，由于线程是Java虚拟机非常宝贵的系统资源，当线程膨胀之后，系统的性能将急剧下降，系统会出现线程堆栈溢出、创建线程失败等问题。</p>
<p>为了改进一线程一连接模型，后来又演进出了一种通过线程池或者消息队列实现1个或者多个线程处理N个客户端的模型，由于它的底层通信机制依然使用同步阻塞I/O，所以被称为“伪异步”。</p>
<h2 id="伪异步I/O编程">伪异步I/O编程</h2><p>后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数M：线程池最大线程数N的比例关系，其中M远大于N，通过线程池可以灵活调配线程资源，设置线程最大值，防止海量并发接入导致线程耗尽。</p>
<p>当有新的客户端接入的时候，将客户端的Socket封装成一个Task投递到后端线程池中进行处理，JDK的线程池维护一个消息队列和N个活跃线程对消息队列中的消息进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少客户端并发访问，都不会导致资源的耗尽和宕机。</p>
<p>伪异步I/O通信框架采用了线程池实现，因此避免了为每个请求都创建一个独立线程造成的线程资源耗尽的问题。但是它底层通信仍采用同步阻塞模型，因此无法从根本上解决问题。</p>
<p>Java输入流 InputStream<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">return</span> <span class="title">read</span><span class="params">(b, <span class="number">0</span>, b.length)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当对Socket输入流进行读取时，操作一直会阻塞下去，直到发生如下几件事情：</p>
<ul>
<li>有数据可读；</li>
<li>可用数据以读取完毕；</li>
<li>发生空指针或者I/O异常。</li>
</ul>
<p>当对方发送消息或者应答消息比较缓慢、或者网络传输较慢时，读取输入流一方的通信线程将长时间阻塞。</p>
<p>Java输出流 OutputStream<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">write</span>(<span class="keyword">byte</span> b[]) <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure></p>
<p>当调用OutputStream 的write方法时，它将会被阻塞，直到所有要发送的字节全部写入完毕，或者发生异常。</p>
<p>通过分析输入和输出流的API文档，我们发现读和写操作都是同步阻塞的，阻塞时间取决于对方的I/O线程处理速度和网络I/O的传播速度。</p>
<h2 id="Non_block_I/O">Non block I/O</h2><p>与Socket和SocketServer类相对应，NIO 也提供的SocketChannel和ServerSocketChannel两种不同的套接字通道实现.这两种新增的通道都支持阻塞和非阻塞两种模式。阻塞模式使用非常简单，但是性能和可靠性都不好。<br>非阻塞模式恰好相反。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/11/30/NIO-Introduce-Abstractly/" data-id="cii02kke2005jjktjz0yjpadt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NIO/">NIO</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-I-O-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/30/java-I-O-2/" class="article-date">
  <time datetime="2015-11-30T06:17:03.000Z" itemprop="datePublished">2015-11-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/30/java-I-O-2/">java-I/O-2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-2_Java_的_I/O演进(2)">1.2 Java 的 I/O演进(2)</h2><p>在JDK1.4退出JavaNIO 之前，基于Java的所有Socket通信都采用了同步阻塞模式（BIO），这种一请求一应答的通信模型简化了上层的阴功开发，但是在性能和可靠性方面却存在着巨大的瓶颈。因此，在很长一段时间里，大型的应用服务器都采用C或者C++语言开发，因为他们可以直接使用操作系统提供的异步I/O或者AIO能力。当并发访问量增大、响应时间延迟增大之后，采用Java BIO开发的服务端软件只能通过硬件的不断扩容来满足高并发和低延迟。</p>
<p>正是由于Java传统BIO的劣势，才使得Java支持非阻塞I/O的呼声渐高，最终JDK1.4版本中提供了新的NIO类库。</p>
<h3 id="Java的I/O简史">Java的I/O简史</h3><p>2002年发布的JDK1.4时，NIO以JSR-51的身份正是随着JDK发布。它增加了java.nio包，提供了很多进行异步I/O开发的API和类库，主要的接口如下：</p>
<ul>
<li>进行异步I/O操作的缓冲区ByteBuffer；</li>
<li>进行异步I/O操作的管道Pipe；</li>
<li>进行各种I/O操作（异步或同步）的Channel，包括ServerSocketChannel和SocketChannel；</li>
<li>多种字符集的编码能力和解码能力；</li>
<li>实现非阻塞I/O操作的多路复用器Selector；</li>
<li>基于流行了Perl实现正则表达式类库；</li>
<li>文件通道FileChannel。</li>
</ul>
<p>新的NIO类库的提供，极大地促进了基于Java的异步非阻塞编程的发展和应用，但是，它依然有不完善的地方，特别是对文件系统的处理能力仍显不足，主要问题如下：</p>
<ul>
<li>没有统一的文件属性；</li>
<li>API能力比较弱，例如目录的级联创建和递归遍历，往往需要自己实现；</li>
<li>底层存储系统的一些高级API无法使用；</li>
<li>所有的文件操作都是同步阻塞调用，不支持异步文件读写操作。</li>
</ul>
<p>2011年7月28日，JDK1.7 正是发布。它的一个比较大亮点就是将原来的NIO类库进行了升级，被称为NIO2.0，有JSR-203演进而来，它主要提供了如下三个方面的改进。</p>
<ul>
<li>提供能够批量获取文件属性的API，这些API具有平台无关性，不与特性的文件系统耦合，另外它还提供了标准文件系统的SPI，供各个服务提供商扩展实现；</li>
<li>提供AIO功能，支持基于文件的异步I/O操作和针对网络套接字的异步操作；</li>
<li>完成JSR-51 定义的通道功能，包括对配置和多播数据包的支持等。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/11/30/java-I-O-2/" data-id="cii02kkca002ujktjzpnpdnor" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaIO/">JavaIO</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-I-O" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/27/java-I-O/" class="article-date">
  <time datetime="2015-11-27T10:26:10.000Z" itemprop="datePublished">2015-11-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/27/java-I-O/">java-I/O-1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java_的_I/O_演进之路(1)">Java 的 I/O 演进之路(1)</h1><p>Java 是 Sun Microsystems 公司在1995年首先发布的编程语言和计算平台。<br>Java 之所以能够得到如此广泛的应用，除了摆脱硬件平台的依赖具有“一次编写、到处运行”的平台无关性之外，另一个重要原因是：丰富而强大的类库以及众多第三方开源类库，使得开发Java程序更加简单和便捷。</p>
<h2 id="1-1_I/O_基础入门">1.1 I/O 基础入门</h2><p>Java 1.4 之前的早期版本，Java 对 I/O 的支持并不完整，开发人员在开发高性能I/O程序的时候，会面临一些巨大的挑战和困难，主要问题如下：</p>
<ul>
<li>没有数据缓冲区，I/O性能存在问题；</li>
<li>没有C或者C++中的Channel概念，只有输入和输出流；</li>
<li>同步阻塞式I/O通信（BIO），通常会导致线程被长时间阻塞；</li>
<li>支持的字符集有限，硬件可移植性不好。</li>
</ul>
<h3 id="1-1-1_Linux_网络I/O模型">1.1.1 Linux 网络I/O模型</h3><p>Linux的内核将所有外部设备都当成一个文件来操作，对一个文件的操作会调用内核提供的系统命令，返回一个file（fd，文件描述符）。而对一个socket的读写，也会有相应的描述符，成为socketfd，描述符就是一个数字，他指向内核的一个结构体（文件属性，数据区等一些属性）。</p>
<p>根据UNIX网络编程对I/O模型的分类，UNIX提供5种I/O模型，分别如下：</p>
<ul>
<li>阻塞I/O模型：缺省条件下都是阻塞I/O模型，所有的文件操作都是阻塞的。以套接字接口为例：在进程空间中调用recvfrom，其系统调用制动数据包到达且被复制到应用进程的缓冲区中或者发生错误时才返回，在此期间一直会等待，进程从调用recvfrom开始到它返回的整段时间内都是被阻塞的，因此被称为阻塞I/O。</li>
<li>非阻塞I/O模型：recvfrom从应用层到内核的时候，如果该缓冲区没有数据的话，就直接返回一个EWOULDBLOCK错误，一般都对非阻塞I/O模型进行轮询检查这个状态，看内核是否有数据过来。</li>
<li>I/O复用模型：Linux提供select/poll，进程通过将一个或多个fd传递给select或者poll系统调用，阻塞在select操作上，这样select/poll可以帮我们侦测多个fd是否处于就绪状态。select/poll是顺序扫描fd是否就绪，而且支持的fd数量有限，因此它的使用受到了一些制约。Linux还提供了一个epoll系统调用，epoll使用基于事件驱动方式代替顺序扫描，当有fd就绪时，立即回调函数rollback。</li>
<li>信号驱动I/O模型：首先开启套接口信号驱动I/O功能，并通过系统调用sigaction执行一个信号处理函数（此系统调用立即返回，进程继续工作，它是非阻塞的）。当数据准备就绪是，就为该进程生成一个SIGIO信号，通过信号回调通知应用程序调用recvfrom来读取数据，并通知主循环函数处理数据。</li>
<li>异步I/O：告知内核启动某个操作，不让内核在整个操作完成后通知我们。与信号驱动模型区别：喜好驱动I/O由内核通知我们何时可以开始一个I/O操作；异步I/O模型由内核通知我们I/O操作何时已经完成。</li>
</ul>
<h3 id="1-1-2_I/O多路复用技术">1.1.2 I/O多路复用技术</h3><p>在I/O编程过程中，当需要同时处理多个客户端接入请求时，可以利用多路线程或者I/O多路复用技术来处理。I/O多路复用把多个I/O阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下同时处理多个客户端的请求。与传统的多线程/多线程模型比，I/O复用的最大优势是系统开销小，系统不需要创建新的额外的进程或者线程，也不需要维护这些线程或进程的运行，降低了系统的维护工作量，节省了系统资源，I/O多路复用的主要应用场景如下：</p>
<ol>
<li>服务器需要同时处理多个处于监听状态或者多个连接状态的套接字；</li>
<li>服务器需要同时处理都中网络协议的套接字；</li>
</ol>
<p>目前支持I/O多路复用的系统调用有select, pselect, poll, epoll,在Linux网络编程中，很长一段时间都使用select做轮询和网络事件通知，Linux的新版本用epoll。起改进如下：</p>
<ul>
<li>一个进程打开的socket描述符（FD）不受限制，仅受限于操作系统的最大文件句柄数。<br>select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由FD_SETSIZE设置，默认是1024.对于那些需要支持上万个TCP链接的大型服务器来说显然是太少了。可以选择修改这个宏然后重新编译内核，不过这会带来网络效率的下降。我们也可以通过选择多进程的方案（传统的Apache方案）解决这个问题，不过虽然在Linux上创建进程的代价比较小，但人就是不可忽视的，另外，进程的数据交换非常麻烦，对于Java由于没有共享内存，需要通过Socket通信或者其他方式进行数据同步，这带来了额外的系能损耗，增加了程序复杂度，所以也不是一种完美的解决方案。epoll并没有这个限制，它所支持的FD上限是操作系统的最大文件句柄数，这个数字远大于1024.cat /proc/sys/fs/file-max，这个值跟系统的内存有关。</li>
<li>I/O的效率不会随着FD数目的增加而直线下降<br>传统的select/poll另一个知名的弱点就是当你拥有一个很大的socket集合，由于网络延迟时或者链路空闲，任意时刻只有少部分的socket是“活跃”的，但是select/poll每次都是扫描全部集合，导致效率的线性下降。epoll不存在这个问题，它只会对“活跃”的socket进行操作-这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的，那么，只有“活跃”的socket才会主动去调用callback函数，其他idle状态socket则不会。epoll实现了一个伪AIO。</li>
<li>使用mmap加速内核与用户空间的消息传递<br>无论是select，poll还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存负值就显得非常重要，epoll是通过内核和用户mmap同一块内存实现。</li>
<li>epoll 的API更加简单</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/11/27/java-I-O/" data-id="cii02kkc8002rjktjzbc8szah" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaIO/">javaIO</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-markdown" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/27/markdown/" class="article-date">
  <time datetime="2015-11-27T10:12:40.000Z" itemprop="datePublished">2015-11-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/27/markdown/">markdown</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MarkDown"><a href="http://www.appinn.com/markdown/" target="_blank" rel="external">MarkDown</a></h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/11/27/markdown/" data-id="cii02kkbz002ijktj5aeotlxt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/markdown/">markdown</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hexo-commands" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/27/hexo-commands/" class="article-date">
  <time datetime="2015-11-27T09:52:48.000Z" itemprop="datePublished">2015-11-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/27/hexo-commands/">Hexo-commands</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Hexo"><a href="http://www.readseek.com/docs/commands.html" target="_blank" rel="external">Hexo</a></h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/11/27/hexo-commands/" data-id="cii02kkcl0038jktj4volyiym" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo/">Hexo</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Flask/">Flask</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hibernate/">Hibernate</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Struts/">Struts</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/fibonacci/">fibonacci</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/socket/">socket</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Abstract/">Abstract</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bloom-Filter/">Bloom Filter</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Classpath/">Classpath</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collections/">Collections</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Configuration/">Configuration</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DTD/">DTD</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Deadlock/">Deadlock</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Duplicate-from-Array/">Duplicate from Array</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Exception/">Exception</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flask-migrate/">Flask migrate</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HQL/">HQL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hashmap/">Hashmap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hibernate/">Hibernate</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Interface/">Interface</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaIO/">JavaIO</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Login/">Login</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVC/">MVC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NIO/">NIO</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OOP/">OOP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ORM/">ORM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Path/">Path</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/QBC/">QBC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Query/">Query</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SVN/">SVN</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Schema/">Schema</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scrapy/">Scrapy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Session/">Session</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sublime-Text2-Plugins-install/">Sublime Text2 Plugins install</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tag/">Tag</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tiles/">Tiles</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tokens/">Tokens</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Validation/">Validation</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XML/">XML</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/component/">component</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/concurrent/">concurrent</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/crawler/">crawler</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hashtable/">hashtable</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javaIO/">javaIO</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/">markdown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/">mongodb</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/multiThread/">multiThread</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-yield/">python yield</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-rq/">python-rq</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/srcapy/">srcapy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stored-procedure/">stored procedure</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/struts/">struts</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/study/">study</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/work-principal/">work principal</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中文乱码/">中文乱码</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/全栈工程师/">全栈工程师</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式爬虫/">分布式爬虫</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/对象映射/">对象映射</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据挖掘/">数据挖掘</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文本处理/">文本处理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/机器学习/">机器学习</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/科学计算/">科学计算</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络爬虫/">网络爬虫</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Abstract/" style="font-size: 10px;">Abstract</a> <a href="/tags/Bloom-Filter/" style="font-size: 10px;">Bloom Filter</a> <a href="/tags/Classpath/" style="font-size: 10px;">Classpath</a> <a href="/tags/Collections/" style="font-size: 10px;">Collections</a> <a href="/tags/Configuration/" style="font-size: 10px;">Configuration</a> <a href="/tags/DTD/" style="font-size: 10px;">DTD</a> <a href="/tags/Deadlock/" style="font-size: 10px;">Deadlock</a> <a href="/tags/Duplicate-from-Array/" style="font-size: 10px;">Duplicate from Array</a> <a href="/tags/Exception/" style="font-size: 10px;">Exception</a> <a href="/tags/Flask-migrate/" style="font-size: 10px;">Flask migrate</a> <a href="/tags/HQL/" style="font-size: 10px;">HQL</a> <a href="/tags/Hashmap/" style="font-size: 10px;">Hashmap</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Hibernate/" style="font-size: 16px;">Hibernate</a> <a href="/tags/Interface/" style="font-size: 10px;">Interface</a> <a href="/tags/JavaIO/" style="font-size: 10px;">JavaIO</a> <a href="/tags/Login/" style="font-size: 10px;">Login</a> <a href="/tags/MVC/" style="font-size: 10px;">MVC</a> <a href="/tags/NIO/" style="font-size: 18px;">NIO</a> <a href="/tags/OOP/" style="font-size: 10px;">OOP</a> <a href="/tags/ORM/" style="font-size: 10px;">ORM</a> <a href="/tags/Path/" style="font-size: 10px;">Path</a> <a href="/tags/QBC/" style="font-size: 10px;">QBC</a> <a href="/tags/Query/" style="font-size: 10px;">Query</a> <a href="/tags/SVN/" style="font-size: 10px;">SVN</a> <a href="/tags/Schema/" style="font-size: 10px;">Schema</a> <a href="/tags/Scrapy/" style="font-size: 10px;">Scrapy</a> <a href="/tags/Session/" style="font-size: 10px;">Session</a> <a href="/tags/Sublime-Text2-Plugins-install/" style="font-size: 10px;">Sublime Text2 Plugins install</a> <a href="/tags/Tag/" style="font-size: 10px;">Tag</a> <a href="/tags/Tiles/" style="font-size: 10px;">Tiles</a> <a href="/tags/Tokens/" style="font-size: 10px;">Tokens</a> <a href="/tags/Validation/" style="font-size: 10px;">Validation</a> <a href="/tags/XML/" style="font-size: 10px;">XML</a> <a href="/tags/component/" style="font-size: 10px;">component</a> <a href="/tags/concurrent/" style="font-size: 10px;">concurrent</a> <a href="/tags/crawler/" style="font-size: 10px;">crawler</a> <a href="/tags/hashtable/" style="font-size: 10px;">hashtable</a> <a href="/tags/java/" style="font-size: 14px;">java</a> <a href="/tags/javaIO/" style="font-size: 10px;">javaIO</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/multiThread/" style="font-size: 10px;">multiThread</a> <a href="/tags/python/" style="font-size: 12px;">python</a> <a href="/tags/python-yield/" style="font-size: 10px;">python yield</a> <a href="/tags/python-rq/" style="font-size: 10px;">python-rq</a> <a href="/tags/srcapy/" style="font-size: 10px;">srcapy</a> <a href="/tags/stored-procedure/" style="font-size: 10px;">stored procedure</a> <a href="/tags/struts/" style="font-size: 20px;">struts</a> <a href="/tags/study/" style="font-size: 10px;">study</a> <a href="/tags/work-principal/" style="font-size: 10px;">work principal</a> <a href="/tags/中文乱码/" style="font-size: 10px;">中文乱码</a> <a href="/tags/全栈工程师/" style="font-size: 10px;">全栈工程师</a> <a href="/tags/分布式爬虫/" style="font-size: 10px;">分布式爬虫</a> <a href="/tags/对象映射/" style="font-size: 10px;">对象映射</a> <a href="/tags/数据挖掘/" style="font-size: 10px;">数据挖掘</a> <a href="/tags/文本处理/" style="font-size: 10px;">文本处理</a> <a href="/tags/机器学习/" style="font-size: 10px;">机器学习</a> <a href="/tags/科学计算/" style="font-size: 10px;">科学计算</a> <a href="/tags/网络爬虫/" style="font-size: 12px;">网络爬虫</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a><span class="archive-list-count">18</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a><span class="archive-list-count">15</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/12/10/NIO-Programing/">NIO-Programing</a>
          </li>
        
          <li>
            <a href="/2015/12/09/JAVA-NIO-Netty/">JAVA-NIO-Netty</a>
          </li>
        
          <li>
            <a href="/2015/12/03/IO-Contrast/">IO-Contrast</a>
          </li>
        
          <li>
            <a href="/2015/12/03/AIO/">AIO</a>
          </li>
        
          <li>
            <a href="/2015/12/02/NIO-library/">NIO-library</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 Zhaohui zhang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>