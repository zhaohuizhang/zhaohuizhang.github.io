<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Welcome To Napu&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="This is zhaohuizhang&apos;s blog site">
<meta property="og:type" content="website">
<meta property="og:title" content="Welcome To Napu's Blog">
<meta property="og:url" content="http://zhaohuizhang.github.io/page/3/index.html">
<meta property="og:site_name" content="Welcome To Napu's Blog">
<meta property="og:description" content="This is zhaohuizhang&apos;s blog site">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Welcome To Napu's Blog">
<meta name="twitter:description" content="This is zhaohuizhang&apos;s blog site">
  
    <link rel="alternative" href="/atom.xml" title="Welcome To Napu&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Welcome To Napu&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hello world，have a nice day!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://zhaohuizhang.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-java-object-method" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/14/java-object-method/" class="article-date">
  <time datetime="2015-05-14T00:06:34.000Z" itemprop="datePublished">2015-05-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/14/java-object-method/">Java Object Method</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java.lang.Object</p>
<p>java.lang 包在使用的时候无需显示导入，编译时由编译器自动导入。</p>
<p>Object类是类层次结构的根，Java类所有的类从根本上都是继承于这个类</p>
<p>Object是唯一没有父类的类</p>
<p>Object 类中的方法</p>
<p><img src="http://images.cnitblog.com/blog/325852/201301/03120453-53ad86e99a464684ab5e89fe6c4089e1.png" alt=""></p>
<p>1，getClass</p>
<p>public final Class&lt;?extends Object&gt; getClass()</p>
<p>返回一个对象的运行时类。该Class对象是由所表示类的static synchronized方法锁定的对象。</p>
<p>2，hashCode</p>
<p>public int hashCode()</p>
<p>返回该对象的哈希码值。支持该方法是为哈希表提供一些优点，例如：java.util.Hashtable提供的哈希表。</p>
<p><code>hashCode</code> 的常规协定是：</p>
<ul>
<li>在 Java 应用程序执行期间，在同一对象上多次调用 <tt>hashCode</tt> 方法时，必须一致地返回相同的整数，前提是对象上 <tt>equals</tt> 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。</li>
<li>如果根据 <tt>equals(Object)</tt> 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 <code>hashCode</code> 方法都必须生成相同的整数结果。</li>
<li>以下情况<em>不</em> 是必需的：如果根据 <a href="/java%20tools/jdk1.5%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/java/lang/Object.html#equals(java.lang.Object"><code>equals(java.lang.Object)</code></a>) 方法，两个对象不相等，那么在两个对象中的任一对象上调用 <tt>hashCode</tt> 方法必定会生成不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能。<br>实际上，由 <tt>Object</tt> 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 Java<sup>TM</sup> 编程语言不需要这种实现技巧。）</li>
</ul>
<p>3，equals</p>
<p>public boolean equals(Object obj)</p>
<p>判断某个对象是否与当前对象相等。</p>
<p><code>equals</code> 方法在非空对象引用上实现相等关系：</p>
<ul>
<li><em>自反性</em>：对于任何非空引用值 <code>x</code>，<code>x.equals(x)</code> 都应返回 <code>true</code>。</li>
<li><em>对称性</em>：对于任何非空引用值 <code>x</code> 和 <code>y</code>，当且仅当 <code>y.equals(x)</code> 返回 <code>true</code> 时，<code>x.equals(y)</code> 才应返回 <code>true</code>。</li>
<li><em>传递性</em>：对于任何非空引用值 <code>x</code>、<code>y</code> 和 <code>z</code>，如果 <code>x.equals(y)</code> 返回 <code>true</code>，并且 <code>y.equals(z)</code> 返回 <code>true</code>，那么 <code>x.equals(z)</code> 应返回 <code>true</code>。</li>
<li><em>一致性</em>：对于任何非空引用值 <code>x</code> 和 <code>y</code>，多次调用 <tt>x.equals(y)</tt> 始终返回 <code>true</code> 或始终返回 <code>false</code>，前提是对象上 <code>equals</code> 比较中所用的信息没有被修改。</li>
<li>对于任何非空引用值 <code>x</code>，<code>x.equals(null)</code> 都应返回 <code>false</code>。<br><code>Object</code> 类的 <tt>equals</tt> 方法实现对象上差别可能性最大的相等关系；即，对于任何非空引用值 <code>x</code> 和 <code>y</code>，当且仅当 <code>x</code> 和 <code>y</code> 引用同一个对象时，此方法才返回 <code>true</code>（<code>x == y</code> 具有值<code>true</code>）。</li>
</ul>
<p>注意：当此方法被重写时，通常有必要重写 <tt>hashCode</tt> 方法，以维护 <tt>hashCode</tt> 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</p>
<dl><dt><strong>参数：</strong></dt><dd><code>obj</code> - 要与之比较的引用对象。</dd><dt><strong>返回：</strong></dt><dd>如果此对象与 obj 参数相同，则返回 <code>true</code>；否则返回 <code>false</code>。</dd></dl>

<p>4，clone</p>
<p>protected Object clone() throws CloneNotSupportedExcetption</p>
<p>创建并返回此对象的一个副本。</p>
<p><tt>Object</tt> 类的 <tt>clone</tt> 方法执行特定的克隆操作。首先，如果此对象的类不能实现接口 <tt>Cloneable</tt>，则会抛出 <tt>CloneNotSupportedException</tt>。注意：所有的数组都被视为实现接口<tt>Cloneable</tt>。否则，此方法会创建此对象的类的一个新实例，并像通过分配那样，严格使用此对象相应字段的内容初始化该对象的所有字段；这些字段的内容没有被自我克隆。所以，此方法执行的是该对象的“浅表复制”，而不“深层复制”操作。</p>
<p><tt>Object</tt> 类本身不实现接口 <tt>Cloneable</tt>，所以在类为 <tt>Object</tt> 的对象上调用 <tt>clone</tt> 方法将会导致在运行时抛出异常。</p>
<dl><dt><strong>返回：</strong></dt><dd>此实例的一个克隆。</dd><dt><strong>抛出：</strong></dt><dd><code>[CloneNotSupportedException](/java%20tools/jdk1.5%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/java/lang/CloneNotSupportedException.html &quot;java.lang 中的类&quot;)</code> - 如果对象的类不支持 <code>Cloneable</code> 接口，则重写 <code>clone</code> 方法的子类也会抛出此异常，以指示无法克隆某个实例。</dd></dl>

<p>5，toString</p>
<p>public String toString()</p>
<p>return getClass().getName()+”@”+Integer.toHexString(hashCode())</p>
<p>6，notify</p>
<p>public final void notify()</p>
<p>唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个<code>wait</code> 方法，在对象的监视器上等待。</p>
<p>7，notifyAll</p>
<p>public final void notifAll()</p>
<p>唤醒在此对象监视器上等待的所有线程。线程通过调用其中一个 <code>wait</code> 方法，在对象的监视器上等待。</p>
<p>8，finalize</p>
<p>protected void finalize() throws Throwable</p>
<p>当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。子类重写 <code>finalize</code> 方法，以配置系统资源或执行其他清除。</p>
<p><tt>finalize</tt> 的常规协定是：当 Java<sup>TM</sup> 虚拟机已确定尚未终止的任何线程无法再通过任何方法访问此对象时，将调用此方法，除非由于准备终止的其他某个对象或类的终结操作执行了某个操作。<tt>finalize</tt> 方法可以采取任何操作，其中包括再次使此对象对其他线程可用；不过，<tt>finalize</tt> 的主要目的是在不可撤消地丢弃对象之前执行清除操作。例如，表示输入/输出连接的对象的 finalize 方法可执行显式 I/O 事务，以便在永久丢弃对象之前中断连接。</p>
<p><tt>Object</tt> 类的 <tt>finalize</tt> 方法执行非特殊性操作；它仅执行一些常规返回。<tt>Object</tt> 的子类可以重写此定义。</p>
<p>Java 编程语言不保证哪个线程将调用某个给定对象的 <tt>finalize</tt> 方法。但可以保证在调用 finalize 时，调用 finalize 的线程将不会持有任何用户可见的同步锁定。如果 finalize 方法抛出未捕获的异常，那么该异常将被忽略，并且该对象的终结操作将终止。</p>
<p>在启用某个对象的 <tt>finalize</tt> 方法后，将不会执行进一步操作，直到 Java 虚拟机再次确定尚未终止的任何线程无法再通过任何方法访问此对象，其中包括由准备终止的其他对象或类执行的可能操作，在执行该操作时，对象可能被丢弃。</p>
<p>对于任何给定对象，Java 虚拟机最多只调用一次 <tt>finalize</tt> 方法。</p>
<p><code>finalize</code> 方法抛出的任何异常都会导致此对象的终结操作停止，但可以通过其他方法忽略它。</p>
<dl><dt><strong>抛出：</strong></dt><dd><code>[Throwable](/java%20tools/jdk1.5%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/java/lang/Throwable.html &quot;java.lang 中的类&quot;)</code> - 此方法抛出的 <code>Exception</code></dd><dd></dd></dl>

<p>9，wait</p>
<p>public final void wait(long time) throws InterruptedException</p>
<p>导致当前的线程等待，直到其他线程调用此对象的 <code>notify()</code> 方法或 <code>notifyAll()</code> 方法，或者超过指定的时间量。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/05/14/java-object-method/" data-id="cihrkq5lg002lestjxxmug4km" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Abstract 与 Interface的区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/13/Abstract 与 Interface的区别/" class="article-date">
  <time datetime="2015-05-12T18:43:38.000Z" itemprop="datePublished">2015-05-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/13/Abstract 与 Interface的区别/">Abstract 与 Interface的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1，abstract class 在Java语言中表示一种继承关系，一个类只能使用一次继承关系。但是一个类可以有多个实现的interface。</p>
<p>2，在Abstract class中可以有自己的数据成员，也可以有非abstract的成员方法，而在interface中，只能够有静态的不能被修改的数据成员（必须是static final，不过在interface里面一般不定义数据成员），所有的成员方法都是abstract的。</p>
<p>3，abstract class和interface所反映出的设计理念不同，其中abstract class表示的是“is - a”关系，interface表示的是“like - a”。</p>
<p>4，实现抽象类和接口的类必须实现其中的所有方法。抽象类中可以有非抽象方法。接口中则不能实现方法。</p>
<p>5，接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变变量。</p>
<p>6，抽象类中的变量默认是friendly型，其值可以再子类中重新定义，也可以重新赋值。</p>
<p>7，接口中的方法默认都是 public abstract 类型的。</p>
<p>总结：</p>
<ul>
<li>接口体现的是一种设计规范，抽象类体现的是模板式设计。</li>
<li>接口里的方法必须是public abstract抽象方法，抽象类里可以有方法实现。</li>
<li>接口里不可以定义静态方法，抽象类可以。</li>
<li>接口里的变量全部为静态常量，抽象类里可有普通变量。</li>
<li>接口里不可以有构造函数和初始化块，抽象类里可以有。</li>
<li>一个类可以实现多个接口，但只能集成一个抽象类。<br>接口是一种非常有效的编程方法，它让对象的定义与实现分离，从而可以在不破坏现有应用程序的情况下使对象得以完善与进化。接口消除了实现继承的一个大问题，就是在对设 计实施后再对其进行更改时很可能对代码产生破坏。即使实现继承允许类从基类继承实现，在类首次发布时仍然会使我们不得不为设计做很多的抉择。如果原有的设想不正确，并非 总可以在以后的版本中对代码进行安全的更改。</li>
</ul>
<p>接口一旦被定义和接受，就必须保持不变，以保护为使用该接口而编写的应用程序。接口发布后，就不能对其进行更改。这是我们进行组件设计的一个重要原则，叫做‘接口不变性’。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/05/13/Abstract 与 Interface的区别/" data-id="cihrkq5q1006festjealt86h9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Abstract/">Abstract</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Interface/">Interface</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-对象入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/12/对象入门/" class="article-date">
  <time datetime="2015-05-12T06:31:01.000Z" itemprop="datePublished">2015-05-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/12/对象入门/">对象入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>OOP（Object-oriented programming）</p>
<p>1，抽象的进步</p>
<p>所有的编程语言的最终目的都是提供一种“抽象”方法。汇编语言是对基础机器的少量抽象，后来许多“命令式”语言（FORTRAN，BASIC，C）是对汇编语言的抽象。与汇编语言相比，这些语言已有了长足的进步，但它们的抽象原理依然要求我们着重考虑计算机的结构，而非考虑问题本身的结构。</p>
<p>我们将问题空间的元素以及它们在方案空间的表示物成为“对象”（Object）。SmallTalk的五大特征，这是第一种成功的面相对象的程序设计语言，也是Java语言的基础：</p>
<ol>
<li>所有的东西都是对象。对象可以想象成一种新型的变量。</li>
<li>程序是一大堆对象的集合。通过消息传递，个对象知道自己该做些什么。为了面向对象发出请求，需向那个对象发送一条消息。</li>
<li>每个对象都有自己的存储空间，可容纳其他对象。或者说通过封装现有对象可制作出新型对象。</li>
<li>每个对象都有一种类型。每个对象都是某一个类的一个实例，其中Class 和 Type 是同义词。一个类的重要特征是“能够将什么消息发送给它”。</li>
<li>同一类的所有对象能够接受相同的信息。对象的“可替代性”<br>2，对象的接口</li>
</ol>
<p>我们向对象发出的请求是通过它的的接口定义的，对象的类型和类则规定了它的接口形式。“类型”和“接口”的等价或对应关系是面向对象程序设计的基础。</p>
<p>3，实现方案的隐藏</p>
<p>客户程序员：收集一个充斥着各种类的编程工具箱，以便能够快速的开发符合自己要求的东西。</p>
<p>类创建者：从头构建一个类，只向客户程序员开放有必要开放的东西（接口），其他所有细节都隐藏起来。</p>
<p>“接口”（Interface）规定了可对一个特定的对象发出哪些请求。然而，必须在某个地方存放着一些代码以便满足这些请求。这些代码以及哪些隐藏起来的数据叫做“隐藏的实现”。</p>
<p>若是任何人都能够使用一个类的所有成员，那么客户程序员可对那个类做任何事情，没有办法强制他们遵守任何约束。有两方面的原因促使我们控制成员的访问。</p>
<p>防止程序员接触他们不该接触的东西，通常是内部数据类型的设计思想。</p>
<p>允许库设计人员修改内部结构，不用担心它会对客户程序员造成什么影响。接口与实现方法早已分开，并分受到保护，用户只需要重新连接一下就好。</p>
<p>Java采用三个显示（明确）关键字以及一个隐式（暗示）关键字来设置类边界：public, private, protected以及暗示性的friendly。若没有明确指定其他关键字，则默认为后者。这些关键字的使用和含义相当直观，它们决定了谁能够使用后续的定义内容。“public”意味着后续的定义任何人均可使用。“private”意味着除了自己、类型创建者以及那个类型的内部函数成员，其他任何人都不能访问后续的定义信息。private在你与客户程序员之间竖起了一堵墙。若有人想访问私有变量成员，就会得到一个编译错误。“friendly”涉及“包装”或“封装”的概念，若某样东西是友好的，意味着它只能在这个包装范围内使用（包装访问）。“protected”与“private”相似，只是一个继承的类可访问受保护的成员，但不能访问私有成员</p>
<p>4，方案的重复使用</p>
<p>代码或设计方案的重复使用是面向对象程序设计提供的最伟大的一种杠杆。</p>
<p>在现有类的基础上组织一个新类—-组织。新类的成员对象通常设为“私有”，使用这个类的客户程序员不能访问它们，这样我们可以不干扰客户代码的前提下，从容的修改那些成员。</p>
<p>由于继承的重要性，所以在面向对象的程序设计中，它通常被重点强调。“继承应当随处可见”，沿用这种思想的设计将是非常笨拙的，会大大增加程序的复杂程度。相反，新建类的时候，首先考虑“组织”对象，这样做显得更加简单和灵活。</p>
<p>5，继承：重新使用接口</p>
<p>继承不完全等同于克隆。若原始类（基础类，父类，超类）发生变化，修改过的“克隆类”（继承类或子类）也会反映这些变化。通过extends关键字来实现。</p>
<p>使用继承时，相当于创建了一个新类。这个新类不仅包含了现有类型的所有成员（尽管private 成员被隐藏 起来，且不能访问），但更重要的是，它复制了基础类的接口。</p>
<p>5.1 改善基础类</p>
<p>尽管extends 关键字暗示着我们要为接口“扩展”新功能，但实情并非肯定如此。为区分我们的新类，第二 个办法是改变基础类一个现有函数的行为。我们将其称作“改善”那个函数。 为改善一个函数，只需为衍生类的函数建立一个新定义即可。我们的目标是：“尽管使用的函数接口未变， 但它的新版本具有不同的表现”。</p>
<p>5.2 等价于类似的关系</p>
<p>我们通常认为基础类和衍生类之间存在一种“等价”关系——因为我们可以理直气壮地说：“圆 就是一种几何形状”。</p>
<p>但在许多时候，我们必须为衍生类型加入新的接口元素。所以不仅扩展了接口，也创建了一种新类型。这种 新类型仍可替换成基础类型，但这种替换并不是完美的，因为不可在基础类里访问新函数。我们将其称作 “类似”关系；新类型拥有旧类型的接口，但也包含了其他函数，所以不能说它们是完全等价的。</p>
<p>6，多形对象的互换作用</p>
<p>通常，继承最终以创建一系列类收场，所有类都建立在统一的接口基础之上。</p>
<p>我们将这种把衍生类当做它的基础类型处理的过程叫做Upcasting。其中cast是指根据一个想成的模型创建；而Up表明继承的方向是从上面来的。</p>
<p>上溯造型的方法用来避免去调查准确类型的一个好办法。</p>
<p>6.1 动态绑定</p>
<p>将一条消息发送给对象时，如果并不知道对方的具体类型是什么，但采取的行动同样是正确的，这种情况就叫做“多形性”。对面向对象的程序设计语言来说，它们用以实现多形性的方法叫做“动态绑定”。</p>
<p>6.2 抽象的基础类和接口</p>
<p>我们经常希望基础类能够给自己的衍生类提供一个接口。使用“abstract”关键字，如果有人试图创建抽象类的一个对象，编译器会阻止他们。可以用“abstract”关键字描述一个尚未实现的方法，作为“根”使用。继承抽象类的衍生类必须实现abstract方法，不然也会变成抽象类。通过创建一个抽象方法，我们可以将一个方法置入接口中，不必再为那个方法提供可能毫无意义的主题代码。</p>
<p>Interface（接口）关键字将抽象类的概念更延伸了一步，它完全禁止了所有的函数定义。“接口”是一种相当有效和常用的工具，另外如果自己愿意，可以将多个接口合并成在一起。</p>
<p>7，对象的创建和存在的时间</p>
<p>对象的创建及破坏方式，对象需要的数据在哪？如何控制对象的“存在时间”呢？</p>
<p>C++ 认为程序的执行效率是最重要的一个问题，所以它允许程序员做出选择。为获得最快的运行速度，存储以及存在时间可在编写程序时指定，只需将对象放置在堆栈或者静态存储区域即可。这样便为存储空间的分配和释放提供了一个优先级。某种情况下这种优先级是非常有价值的。</p>
<p>在一个内存池中动态的创建对象，该内存池也叫“堆”或“内存堆”。若采用这种方式，除非进入运行期，否则根本不知道到底需要多少个对象，也不知道它们的存在时间有多长，以及准确的类型是什么？</p>
<p>存储空间的管理是在运行期动态进行的，所以在内存堆里分配存储空间的时间比在堆栈里创建的时间长的多。</p>
<p>C++允许我们决定是在写程序时创建对象，还是在运行时创建对象，这种控制方法更加灵活。对象的生存时间“Lifttime”。若在堆栈或者静态存储空间里创建一个对象，编译器会判断对象的持续时间有多长，会到时自动“破坏”或者“清除”它。程序员可用两种方式破会一个对象：用程序话方法来决定何时破坏对象，或者利用由运行环境提供的一种“垃圾收集器”的特性，自动寻找那些不再使用的对象，并将其清除。</p>
<p>7.1 集合与继承器</p>
<p>集，队列，散列表，数，堆栈等等。所有的集合都提供了相应的读写功能。Push，Add功能。</p>
<p>继承器（Iterator），它属于一种对象，负责选择集合内的元素，并把它们提供给继承器的用户。最早的标准继承器（Enumeration），java1.2中添加Iteration。</p>
<p>根据具体的需求选择集合类型。</p>
<p>7.2 单根结构</p>
<p>在Java中所有类都继承于Object类，单根结构有很多优点：</p>
<ul>
<li>都有相同的类型</li>
<li>不会判断不出一个对象的类型</li>
<li>方便省事，适用于新手，我们可以更方便的实现一个垃圾收集器<br>7.3 集合库与方便使用集合</li>
</ul>
<p>下塑造性与模板/通用性</p>
<p>Downcasting。从一个集合中提取对象句柄时，必须用某些方法记住它，以保证下塑造性的正确进行。利用参数化类型，定制集合。</p>
<p>7.4 对象清除</p>
<p>在Java中，垃圾收集器在设计时已考虑到了内存的释放问题。垃圾收集器“知道”一个对象在什么时候不再使用，让后会自动释放那个对象占据的内存空间，采用这种方式，另外加上所有对象都从单根Object继承的事实，而且由于我们只能在内存堆中以一种方式创建对象，所以Java的编程要比C++ 的编程简单得多。</p>
<p>垃圾收集器对效率的影响</p>
<p>Java是在运行时动态的创建对象，C++则是在堆栈中创建对象。在堆栈中创建对象是为对象分配存储空间最有效的一种方式，也是释放那些空间最有效的一种方式。在内存堆（Heap）中创建对象可能要付出昂贵的代价，如果总是从同一基础类继承，并使用所有函数调用都具有“同质多形”特征，那么也不可避免地需要付出一定的代价。</p>
<p>8 违例控制：解决错误</p>
<p>“违例控制”是将错误控制方案内置到程序设计语言中，有时甚至内建到操作系统内。“Exception”特殊的对象，从产生错误的地方抛出。Java中的为例控制模块从一开始就封装好的，所以必须使用它。</p>
<p>9 多线程</p>
<p>在计算机编程中，一个最基本的概念就是同时对多个任务加以控制。最早是“中断服务例程”，主进程暂时通过硬件级的中断实现的。很难移植，造成了另一类的代价高昂的问题。中断对于那些实时性很强的任务来说是必要的。但还存在其他许多问题，，它们只要求将问题划分进入独立运行的程序片断中，使整个程序快速更迅速地响应用户的请求。在一个程序中，这些独立运行的片断叫做“线程”，利用它编程的概念叫做“多线程处理”。多线程处理一个常见的例子就是用户界面。利用线程，用户可以按下一个按钮，然后程序会立即做出响应，而不是让用户等待程序完成当前任务后再开始响应。最开始，线程只是用于分配单个处理器的处理时间的一种工具。但假如操作系统支持多个处理器，那么每个线程都可以分配给一个不同的处理器，真正进入“并行计算”状态。从程序设计语言的角度看，多线程操作最优价值的特性之一就是程序员不必关系到底使用多少个处理器。程序在逻辑意义上被划分出多个线程。多线程处理的问题：共享资源。一个线程可以将资源锁定，在完成了它的任务后，再解开这个锁，使其他线程可以接着使用同样的资源。</p>
<p>Java的多线程机制已经内建在语言中了，这使一个可能较复杂的问题简单起来。对多线程支持是在对象这一级支持的，所以一个执行线程可以表达为一个对象。Java也提供了有限的资源锁定方案。它能锁定任何对象占用的内存，所以同一时间只能有一个线程使用特定的内存空间。未达到这个目的使用synchronized关键字。其他类型的资源必须有程序员明确锁定，这通常要求程序员创建一个对象，用它代表一种锁，所有线程在访问那个资源是都必须检查这个锁。</p>
<p>10，永久性</p>
<p>创建一个对象后，只要我们需要，它就会一直存在下去。但在程序的运行结束后，对象的生存期也宣告结束。</p>
<p>11，分析与设计</p>
<p>对象是什么？（怎样将自己的项目分割成组件）</p>
<p>它们的接口是什么？（需要将什么消息发给每一个对象）</p>
<p>阶段0 ，计划：决定后面的过程，有阶段性的工作任务。</p>
<p>阶段1，要制作什么：建立需求分析和系统规格，估算出时间。</p>
<p>阶段2，如何创建：必须拿出一套设计方案，并解释其中包含各类对象在外观上是什么样子，以及相互间是如何沟通的。此时用“UML”。</p>
<p>阶段3，开始创建：先拿出一套较为全面的方案，使其尽可能的设想周全。</p>
<p>阶段4，校订：改变。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/05/12/对象入门/" data-id="cihrkq5k40010estjp0f2qvuw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OOP/">OOP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HashMap 和 HashTable的区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/11/HashMap 和 HashTable的区别/" class="article-date">
  <time datetime="2015-05-11T06:03:57.000Z" itemprop="datePublished">2015-05-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/11/HashMap 和 HashTable的区别/">HashMap 和 HashTable的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1，类的定义</p>
<p><pre>Public class Hashtable extends Dictionary implements Map, Cloneable, java.io.Serializable</pre></p>
<p>Public class HashMap extends AbstractMap implements Map, Cloneable, Serializable<br>可见Hashtable继承自Dictionary而HashMap继承自AbstractMap</p>
<p>Hashtable的put方法</p>
<p><pre>public synchronized V put(K key, V value){<br>    if(value == null){<br>    throws new NullPointerException();<br> }<br>    Entry tab[] = table;<br>    int hash = key.hashCode();<br>    int index = (hash $ 0x7FFFFFFF)% tab.length;<br>    for(Entry e = tab[index]; e != null; e=e.next){<br>        if((e.hash == hash)&amp;&amp;e.key.equals(key)){<br>        V old = e.value;<br>        e.value = value;<br>        return old;<br>    }<br>  }<br>    modCount++;<br>    if(count &gt;= threshold){<br>    rehash();<br>    tab = table;<br>    index = (hash &amp; 0x7FFFFFFF) % tab.length;<br>    }<br>    Entry e = tab[index];<br>    tab[index] = new Entry(hash,key,value,e);<br>    count++;<br>    return null;<br>}</pre><br>1，put方法时同步的</p>
<p>2，方法不允许value==null</p>
<p>3，方法调用了key的hashCode方法，如果key == null，会抛出空指针异常</p>
<p>HashMap的put方法</p>
<p><pre>public V put(K key, V value){//#####<br>    if(key == null)//####<br>        return putForNullKey(value);<br>    int hash = hash(key.hashCode());<br>    int i = indexFor(hash, table.length);<br>    for(Entry e=table[i];e!=null; e=e.next){<br>         Object k;<br>         if(e.hash == hash &amp;&amp; ((k = e.key)==key||key.equals(k))){<br>                V oldValue = e.value;<br>                e.value = value;<br>                e.recordAccess(this);<br>                return oldValue;<br>        }<br>    }<br>    modCount++;<br>    addEntry(hash, key, value, i);//###<br>    return null;<br>}</pre><br>1，方法为非同步的</p>
<p>2，方法允许key==null</p>
<p>3，方法并没有对value值做任何调整，所以允许null</p>
<p><table></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><td></td></p>
<p><td>HashMap</td></p>
<p><td>HashTable</td><br></p>
<p><tr></tr></p>
<p><td>父类</td></p>
<p><td>AbstractMap</td></p>
<p><td>Dictionary</td><br></p>
<p><tr></tr></p>
<p><td>Value是否为空</td></p>
<p><td>可为空</td></p>
<p><td>不可</td><br><br><br><br>HashMap是HashTable的轻量级实现（非线程安全的实现），他们都完成了Map接口。</p>
<p>主要区别在于HashMap允许空（null）键值（key），由于非线程安全，效率上可能高于HashTable。</p>
<p>HashMap把Hashtable的contains方法去掉，改成containsvalue和containsKey。因为contains方法容易让人引起误解。</p>
<p>Hashtable继承自Dictionary类，而HashMap是Map interface的接口。</p>
<p>最大的不同是，Hashtable的方法时Synchronize的，而HashMap不是，在多线程访问Hashtable时，不需要自己为它的方法同步，而HashMap就必须为之提供同步Collection.synchronizedMap。</p>
<p>Hashtable和HashMap采用hash/rehash算法都大概一样，所以性能不会有很大的差异。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/05/11/HashMap 和 HashTable的区别/" data-id="cihrkq5py0069estjotze5d7c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hashmap/">Hashmap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hashtable/">hashtable</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-socket blocking noblocking IO model" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/08/socket blocking noblocking IO model/" class="article-date">
  <time datetime="2015-05-07T20:08:19.000Z" itemprop="datePublished">2015-05-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/socket/">socket</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/08/socket blocking noblocking IO model/">socket阻塞与非阻塞，同步与异步、I/O模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>转载：</p>
<h1 id="socket阻塞与非阻塞，同步与异步、I/O模型"><span class="link_title"><a href="http://blog.csdn.net/hguisu/article/details/7453390" target="_blank" rel="external">socket阻塞与非阻塞，同步与异步、I/O模型</a></span></h1><p>1. 概念理解</p>
<pre><code>在进行网络编程时，我们常常见到同步<span class="comment">(Sync)</span>/异步<span class="comment">(Async)</span>，阻塞<span class="comment">(Block)</span>/非阻塞<span class="comment">(Unblock)</span>四种调用方式：
</code></pre><p><strong>同步：</strong><br>所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。<strong>也就是必须一件一件事做</strong><span lang="EN-US">,</span>等前一件做完了才能做下一件事。</p>
<p>例如普通B/S模式（同步）：提交请求-&gt;等待服务器处理-&gt;处理完毕返回 这个期间客户端浏览器不能干任何事</p>
<p><strong>异步：</strong><br>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p>
<p>例如 ajax请求（异步）<span lang="EN-US">: </span>请求通过事件触发<span lang="EN-US">-&gt;</span>服务器处理（这是浏览器仍然可以作其他事情）<span lang="EN-US">-&gt;</span>处理完毕</p>
<p><strong>阻塞</strong><br>阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。</p>
<p>有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。 例如，我们在socket中调用recv函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。</p>
<p><strong>快递的例子：</strong>比如到你某个时候到A楼一层（假如是内核缓冲区）取快递，但是你不知道快递什么时候过来，你又不能干别的事，只能死等着。但你可以睡觉（进程处于休眠状态），因为你知道快递把货送来时一定会给你打个电话（假定一定能叫醒你）。</p>
<p><strong>非阻塞</strong><br>非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p>
<p>还是等快递的例子：如果用忙轮询的方法，每隔5分钟到A楼一层(内核缓冲区）去看快递来了没有。如果没来，立即返回。而快递来了，就放在A楼一层，等你去取。<br>对象的阻塞模式和阻塞函数调用<br>对象是否处于阻塞模式和函数是不是阻塞调用有很强的相关性，但是并不是一一对应的。阻塞对象上可以有非阻塞的调用方式，我们可以通过一定的API去轮询状 态，在适当的时候调用阻塞函数，就可以避免阻塞。而对于非阻塞对象，调用特殊的函数也可以进入阻塞调用。函数select就是这样的一个例子。</p>
<p>&nbsp;</p>
<p>1. 同步，就是我调用一个功能，该功能没有结束前，我死等结果。<br>2. 异步，就是我调用一个功能，不需要知道该功能结果，该功能有结果后通知我（回调通知）<br>3. 阻塞，      就是调用我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回。<br>4. 非阻塞，  就是调用我（函数），我（函数）立即返回，通过select通知调用者</p>
<p>同步IO和异步IO的区别就在于：数据拷贝的时候进程是否阻塞！</p>
<p>阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回！</p>
<p>&nbsp;</p>
<p>对于举个简单c/s 模式：</p>
<div>同步：提交请求-&gt;等待服务器处理-&gt;处理完毕返回这个期间客户端浏览器不能干任何事<br>异步：请求通过事件触发-&gt;服务器处理（这是浏览器仍然可以作其他事情）-&gt;处理完毕</div><br><div>同步和异步都只针对于本机SOCKET而言的。</div><br><div><br><br>同步和异步,阻塞和非阻塞,有些混用,其实它们完全不是一回事,而且它们修饰的对象也不相同。<br>阻塞和非阻塞是指当进程访问的数据如果尚未就绪,进程是否需要等待,简单说这相当于函数内部的实现区别,也就是未就绪时是直接返回还是等待就绪;<br><br>而同步和异步是指访问数据的机制,同步一般指主动请求并等待I/O操作完毕的方式,当数据就绪后在读写的时候必须阻塞(区别就绪与读写二个阶段,同步的读写必须阻塞),异步则指主动请求数据后便可以继续处理其它任务,随后等待I/O,操作完毕的通知,这可以使进程在数据读写时也不阻塞。(等待”通知”)<br><br>node.js里面的描述：<br><div class="dp-highlighter bg_html"><br><br>1.  线程在执行中如果遇到磁盘读写或网络通信（统称为I/O 操作），通常要耗费较长的时间，这时操作系统会剥夺这个线程的CPU 控制权，使其暂停执行，同时将资源让给其他的工作线程，这种线程调度方式称为 阻塞。当I/O 操作完毕时，操作系统将这个线程的阻塞状态解除，恢复其对CPU的控制权，令其继续执行。这种I/O 模式就是通常的同步式I/O（Synchronous I/O）或阻塞式I/O （Blocking I/O）。<br>2.  相应地，异步式I/O （Asynchronous I/O）或非阻塞式I/O （Non-blocking I/O）则针对所有I/O 操作不采用阻塞的策略。当线程遇到I/O 操作时，不会以阻塞的方式等待I/O 操作的完成或数据的返回，而只是将I/O 请求发送给操作系统，继续执行下一条语句。当操作系统完成I/O 操作时，以事件的形式通知执行I/O 操作的线程，线程会在特定时候处理这个事件。为了处理异步I/O，线程必须有事件循环，不断地检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，<span class="tag">&lt;</span><span class="tag-name">span</span> <span class="attribute">style</span>=<span class="attribute-value">“color:#ff0000;”</span><span class="tag">&gt;</span>这个线程所使用的CPU 核心利用率永远是100%<span class="tag">&lt;/</span><span class="tag-name">span</span><span class="tag">&gt;</span>，I/O 以事件的方式通知。<span class="tag">&lt;</span><span class="tag-name">span</span> <span class="attribute">style</span>=<span class="attribute-value">“color:#ff0000;”</span><span class="tag">&gt;</span>在阻塞模式下，多线程往往能提高系统吞吐量，因为一个线程阻塞时还有其他线程在工作，多线程可以让CPU 资源不被阻塞中的线程浪费。<span class="tag">&lt;/</span><span class="tag-name">span</span><span class="tag">&gt;</span>而在非阻塞模式下，线程不会被I/O 阻塞，永远在利用CPU。多线程带来的好处仅仅是在多核CPU 的情况下利用更多的核，而Node.js的单线程也能带来同样的好处。这就是为什么Node.js 使用了单线程、非阻塞的事件编程模式。<br></div><br></div>

<h2 id=""><a name="t1"></a></h2><p>2. Linux下的五种I/O模型</p>
<div>

<p>1)阻塞I/O（blocking I/O）<br>2)非阻塞I/O （nonblocking I/O）<br>3) I/O复用(select 和poll) （I/O multiplexing）<br>4)信号驱动I/O （signal driven I/O (SIGIO)）<br>5)异步I/O （asynchronous I/O (the POSIX aio_functions)）</p>
<p>前四种都是同步，只有最后一种才是异步IO。</p>
<h4 id="阻塞I/O模型："><a name="t2"></a><strong>阻塞I/O模型：</strong></h4><p>简介：进程会一直阻塞，直到数据拷贝完成</p>
<p>应用程序调用一个IO函数，导致应用程序阻塞，等待数据准备好。 如果数据没有准备好，一直等待….数据准备好了，从内核拷贝到用户空间,IO函数返回成功指示。</p>
<p>我们 第一次接触到的网络编程都是从 listen()、send()、recv()等接口开始的。使用这些接口可以很方便的构建服务器 /客户机的模型。</p>
<p><strong>阻塞I/O模型图：</strong>在调用recv()/recvfrom（）函数时，发生在内核中等待数据和复制数据的过程。</p>
<p><img src="http://my.csdn.net/uploads/201204/12/1334216532_9745.jpg" alt=""></p>
<p>当调用recv()函数时，系统首先查是否有准备好的数据。如果数据没有准备好，那么系统就处于等待状态。当数据准备好后，将数据从<strong>系统缓冲区</strong>复制到用户空间，然后该函数返回。在套接应用程序中，当调用recv()函数时，未必用户空间就已经存在数据，那么此时recv()函数就会处于等待状态。</p>
<p>当使用socket()函数和WSASocket()函数创建套接字时，默认的套接字都是阻塞的。这意味着当调用Windows Sockets API不能立即完成时，线程处于等待状态，直到操作完成。</p>
<p>并不是所有Windows Sockets API以阻塞套接字为参数调用都会发生阻塞。例如，以阻塞模式的套接字为参数调用bind()、listen()函数时，函数会立即返回。将可能阻塞套接字的Windows Sockets API调用分为以下四种:</p>
<p>1．输入操作： recv()、recvfrom()、WSARecv()和WSARecvfrom()函数。以阻塞套接字为参数调用该函数接收数据。如果此时套接字缓冲区内没有数据可读，则调用线程在数据到来前一直睡眠。</p>
<p>2．输出操作： send()、sendto()、WSASend()和WSASendto()函数。以阻塞套接字为参数调用该函数发送数据。如果套接字缓冲区没有可用空间，线程会一直睡眠，直到有空间。</p>
<p>3．接受连接：accept()和WSAAcept()函数。以阻塞套接字为参数调用该函数，等待接受对方的连接请求。如果此时没有连接请求，线程就会进入睡眠状态。</p>
<p>4．外出连接：connect()和WSAConnect()函数。对于TCP连接，客户端以阻塞套接字为参数，调用该函数向服务器发起连接。该函数在收到服务器的应答前，不会返回。这意味着TCP连接总会等待至少到服务器的一次往返时间。</p>
<p>使用阻塞模式的套接字，开发网络程序比较简单，容易实现。当希望能够立即发送和接收数据，且处理的套接字数量比较少的情况下，使用阻塞模式来开发网络程序比较合适。</p>
<p>阻塞模式套接字的不足表现为，在大量建立好的套接字线程之间进行通信时比较困难。当使用“生产者-消费者”模型开发网络程序时，为每个套接字都分别分配一个读线程、一个处理数据线程和一个用于同步的事件，那么这样无疑加大系统的开销。其最大的缺点是当希望同时处理大量套接字时，将无从下手，其扩展性很差.</p>
<p>阻塞模式给网络编程带来了一个很大的问题，如在调用 send()的同时，线程将被阻塞，在此期间，线程将无法执行任何运算或响应任何的网络请求。这给多客户机、多业务逻辑的网络编程带来了挑战。这时，我们可能会选择多线程的方式来解决这个问题。</p>
<p>应对多客户机的网络应用，最简单的解决方式是在服务器端使用多线程（或多进程）。多线程（或多进程）的目的是让每个连接都拥有独立的线程（或进程），这样任何一个连接的阻塞都不会影响其他的连接。</p>
<p>具体使用多进程还是多线程，并没有一个特定的模式。传统意义上，进程的开销要远远大于线程，所以，如果需要同时为较多的客户机提供服务，则不推荐使用多进程；如果单个服务执行体需要消耗较多的 <span id="dc52mg8ruzd1_6" class="dc52mg8ruzd1">CPU</span> 资源，譬如需要进行大规模或长时间的数据运算或文件访问，则进程较为安全。通常，使用 pthread_create () 创建新线程，<span id="dc52mg8ruzd1_3" class="dc52mg8ruzd1">fork</span>() 创建新进程。</p>
<p>多线程/进程服务器同时为多个客户机提供应答服务。模型如下：</p>
<p><img src="http://img.blog.csdn.net/20140818224818116?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGd1aXN1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>主线程持续等待客户端的连接请求，如果有连接，则创建新线程，并在新线程中提供为前例同样的问答服务。</p>
<p>上述多线程的服务器模型似乎完美的解决了为多个客户机提供问答服务的要求，但其实并不尽然。如果要同时响应成百上千路的连接请求，则无论多线程还是多进程都会严重占据系统资源，降低系统对外界响应效率，而线程与进程本身也更容易进入假死状态。</p>
<p>由此可能会考虑使用“<strong>线程池</strong>”或“<strong>连接池</strong>”。“线程池”旨在减少创建和销毁线程的频率，其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务。“连接池”维持连接的缓存池，尽量重用已有的连接、减少创建和关闭连接的频率。这两种技术都可以很好的降低系统开销，都被广泛应用很多大型系统，如apache，mysql数据库等。</p>
<p>但是，“线程池”和“连接池”技术也只是在一定程度上缓解了频繁调用 IO 接口带来的资源占用。而且，所谓“池”始终有其上限，当请求大大超过上限时，“池”构成的系统对外界的响应并不比没有池的时候效果好多少。所以使用“池”必须考虑其面临的响应规模，并根据响应规模调整“池”的大小。</p>
<p>对应上例中的所面临的可能同时出现的上千甚至上万次的客户端请求，“线程池”或“连接池”或许可以缓解部分压力，但是不能解决所有问题。</p>
<h4 id="非阻塞IO模型_："><a name="t3"></a><strong>非阻塞IO模型</strong> ：</h4><p></p></div><p></p>
<p><div>       简介：非阻塞IO通过进程反复调用IO函数（多次系统调用，并马上返回）；在数据拷贝的过程中，进程是阻塞的；</div><br>&nbsp;</p>
<p>我们把一个SOCKET接口设置为非阻塞就是告诉内核，当所请求的I/O操作无法完成时，<strong>不要将进程睡眠</strong>，而是返回一个错误。这样我们的I/O操作函数将不断的测试数据是否已经准备好，如果没有准备好，继续测试，直到数据准备好为止。在这个不断测试的过程中，会大量的占用CPU的时间。</p>
<p>把SOCKET设置为非阻塞模式，即通知系统内核：在调用Windows Sockets API时，不要让线程睡眠，而应该让函数立即返回。在返回时，该函数返回一个错误代码。图所示，一个非阻塞模式套接字多次调用recv()函数的过程。前三次调用recv()函数时，内核数据还没有准备好。因此，该函数立即返回WSAEWOULDBLOCK错误代码。第四次调用recv()函数时，数据已经准备好，被复制到应用程序的缓冲区中，recv()函数返回成功指示，应用程序开始处理数据。</p>
<p><img src="http://my.csdn.net/uploads/201204/12/1334216607_3004.jpg" alt=""></p>
<p>当使用socket()函数和WSASocket()函数创建套接字时，默认都是阻塞的。在创建套接字之后，通过调用ioctlsocket()函数，将该套接字设置为非阻塞模式。Linux下的函数是:fcntl().<br>套接字设置为非阻塞模式后，在调用Windows Sockets API函数时，调用函数会立即返回。大多数情况下，这些函数调用都会调用“失败”，并返回WSAEWOULDBLOCK错误代码。说明请求的操作在调用期间内没有时间完成。通常，应用程序需要重复调用该函数，直到获得成功返回代码。</p>
<p>需要说明的是并非所有的Windows Sockets API在非阻塞模式下调用，都会返回WSAEWOULDBLOCK错误。例如，以非阻塞模式的套接字为参数调用bind()函数时，就不会返回该错误代码。当然，在调用WSAStartup()函数时更不会返回该错误代码，因为该函数是应用程序第一调用的函数，当然不会返回这样的错误代码。</p>
<p>要将套接字设置为非阻塞模式，除了使用ioctlsocket()函数之外，还可以使用WSAAsyncselect()和WSAEventselect()函数。当调用该函数时，套接字会自动地设置为非阻塞方式。</p>
<p>由于使用非阻塞套接字在调用函数时，会经常返回WSAEWOULDBLOCK错误。所以在任何时候，都应仔细检查返回代码并作好对“失败”的准备。应用程序连续不断地调用这个函数，直到它返回成功指示为止。上面的程序清单中，在While循环体内不断地调用recv()函数，以读入1024个字节的数据。这种做法很浪费系统资源。</p>
<p>要完成这样的操作，有人使用MSG_PEEK标志调用recv()函数查看缓冲区中是否有数据可读。同样，这种方法也不好。因为该做法对系统造成的开销是很大的，并且应用程序至少要调用recv()函数两次，才能实际地读入数据。较好的做法是，使用套接字的“I/O模型”来判断非阻塞套接字是否可读可写。</p>
<p>非阻塞模式套接字与阻塞模式套接字相比，不容易使用。使用非阻塞模式套接字，需要编写更多的代码，以便在每个Windows Sockets API函数调用中，对收到的WSAEWOULDBLOCK错误进行处理。因此，非阻塞套接字便显得有些难于使用。</p>
<p>但是，非阻塞套接字在控制建立的多个连接，在数据的收发量不均，时间不定时，明显具有优势。这种套接字在使用上存在一定难度，但只要排除了这些困难，它在功能上还是非常强大的。通常情况下，可考虑使用套接字的“I/O模型”，它有助于应用程序通过异步方式，同时对一个或多个套接字的通信加以管理。</p>
<p>&nbsp;</p>
<h3 id="IO复用模型："><a name="t4"></a><strong>IO复用模型：</strong></h3><p>简介：主要是select和epoll；对一个IO端口，两次调用，两次返回，比阻塞IO并没有什么优越性；关键是能实现同时对多个IO端口进行监听；</p>
<p>I/O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这两个函数可以同时阻塞多个I/O操作。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数。</p>
<p><img src="http://my.csdn.net/uploads/201204/12/1334216620_6310.jpg" alt=""></p>
<h3 id="信号驱动IO"><a name="t5"></a><strong>信号驱动IO</strong></h3><p>简介：两次调用，两次返回；</p>
<p>首先我们允许套接口进行信号驱动I/O,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。</p>
<p><img src="http://my.csdn.net/uploads/201204/12/1334216632_6025.jpg" alt=""></p>
<h3 id="异步IO模型"><a name="t6"></a><strong>异步IO模型</strong></h3><p>简介：数据拷贝的时候进程无需阻塞。</p>
<p><strong>     </strong>当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者的输入输出操作</p>
<p><img src="http://my.csdn.net/uploads/201204/12/1334216641_7821.jpg" alt=""></p>
<p>同步IO引起进程阻塞，直至IO操作完成。<br>异步IO不会引起进程阻塞。<br>IO复用是先通过select调用阻塞。</p>
<h3 id="5个I/O模型的比较："><a name="t7"></a><strong>5个I/O模型的比较：</strong></h3><p><img src="http://my.csdn.net/uploads/201204/12/1334216724_2405.jpg" alt=""></p>
<h2 id="-1"><a name="t8"></a></h2><p>3. select、poll、epoll简介</p>
<p>epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现</p>
<p><strong>select：</strong></p>
<p>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：</p>
<p>1、 单个进程可监视的fd数量被限制，即能监听端口的大小有限。</p>
<p>一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.</p>
<p>2、 对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低：</p>
<p>当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</p>
<p>3、需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大</p>
<p><strong>poll：</strong></p>
<p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p>
<p>它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个缺点：</p>
<p>1、大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。                                                                                                                                      2、poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</p>
<p><strong>epoll:</strong></p>
<p>epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就需态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知</p>
<p>epoll的优点：</p>
<p><div><strong>1、没有最大并发连接的限制，</strong>能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；<br><strong>2、效率提升</strong>，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；<br>即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</div></p>
<p><div><strong>3、 内存拷贝</strong>，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</div></p>
<p><strong>select、poll、epoll 区别总结：</strong><br>1、支持一个进程所能打开的最大连接数</p>
<p><table border="1" cellspacing="0" cellpadding="0"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><td width="111">select</td></p>
<p><td width="457">单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32<em>32，同理64位机器上FD_SETSIZE为32</em>64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。</td><br></p>
<p><tr></tr></p>
<p><td width="111">poll</td></p>
<p><td width="457">poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的</td><br></p>
<p><tr></tr></p>
<p><td width="111">epoll</td></p>
<p><td width="457">虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接</td><br><br><br><br>2、FD剧增后带来的IO效率问题</p>
<p><table border="1" cellspacing="0" cellpadding="0"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><td width="111">select</td></p>
<p><td width="457">因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。</td><br></p>
<p><tr></tr></p>
<p><td width="111">poll</td></p>
<p><td width="457">同上</td><br></p>
<p><tr></tr></p>
<p><td width="111">epoll</td></p>
<p><td width="457">因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。</td><br><br><br><br>3、 消息传递方式</p>
<p><table border="1" cellspacing="0" cellpadding="0"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><td width="111">select</td></p>
<p><td width="457">内核需要将消息传递到用户空间，都需要内核拷贝动作</td><br></p>
<p><tr></tr></p>
<p><td width="111">poll</td></p>
<p><td width="457">同上</td><br></p>
<p><tr></tr></p>
<p><td width="111">epoll</td></p>
<p><td width="457">epoll通过内核和用户空间共享一块内存来实现的。</td><br><br><br><br><strong>总结：</strong></p>
<p>综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点。</p>
<p>1、表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</p>
<p>2、select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/05/08/socket blocking noblocking IO model/" data-id="cihrkq5kt001sestjq09vfwng" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Hibernate 数据查询" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/07/Hibernate 数据查询/" class="article-date">
  <time datetime="2015-05-07T01:19:25.000Z" itemprop="datePublished">2015-05-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Hibernate/">Hibernate</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/07/Hibernate 数据查询/">Hibernate 数据查询</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>HQL（Hibernate Query Language, HQL），它是Hibernate的面向对象的查询语言。</p>
<p>1，创建查询对象<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Query</span> <span class="keyword">query</span> = session.createQuery(<span class="string">"from Dept"</span>);</span><br></pre></td></tr></table></figure></p>
<p>2，执行查询列出结果<br>(1)列出所有的结果</p>
<p>调用Query对象的list()方法可以返回所有结果的列表。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">List</span>&lt;Dept&gt; depts = <span class="keyword">query</span>.<span class="keyword">list</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Dept dept:depts)&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>(2)列出单个结果<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Query</span> <span class="keyword">query</span> = session.createQuery(<span class="string">"from Dept where id=1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">query</span>.setMaxResults(1);</span><br><span class="line"></span><br><span class="line">Dept dept = (Dept) <span class="keyword">query</span>.uniqueResult();</span><br></pre></td></tr></table></figure></p>
<p>(3)迭代访问结果<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Query</span> <span class="keyword">query</span>  = session.createQuery(<span class="string">"from Dept"</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;Dept&gt; it = <span class="keyword">query</span>.iterate();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(it.next())&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>3，HQL基本语法</p>
<p>(1)选择要查询的持久化类<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String </span>hql = <span class="string">"from Dept as d"</span></span><br></pre></td></tr></table></figure></p>
<p>Dept为持久化类名。区分大小写.</p>
<p>(2)投影查询</p>
<p>与SQL语句类似，HQL可以只查询出某一个或某几个属性，用select关键字来指定查询的属性名。Select id,name from Dept;</p>
<p>可以构造两个属性参数的构造函数。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public DeptRow(Long <span class="property">id</span>, String <span class="property">name</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">Select new DeptRow(<span class="property">id</span>,<span class="property">name</span>) <span class="keyword">from</span> Dept;</span><br></pre></td></tr></table></figure></p>
<p>(3)where 条件句</p>
<ul>
<li>比较运算：=、&lt;、&gt;、 =、等等</li>
<li>范围运算：in、 not in、 between、 not between</li>
<li>字符串模式匹配：like，”%” 代表任意长度的字符串，代表任意单个字符。</li>
<li>逻辑运算符：and、or、not</li>
<li>is empty、is not empty</li>
<li>upper(s), lower(s),concat(s1,s2),substring(s,offset,length),trim(s),length(s),locate(search,s,offset),abs(n),sqrt(n),mod(dividend,divisor)求余数,size(c)返回集合元素的个数,current_date(),current_time(),current_timestamp(),year(d)month(d)day(d)hour(d)minute(d)second(d)</li>
</ul>
<p>(4)绑定查询参数</p>
<p>动态绑定查询参数或者字符串拼接（又注入的安全问题）</p>
<p>按照参数名字绑定，“:”<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> hql = <span class="string">"from Dept where id&gt; :id and name like :likename"</span>;</span><br><span class="line"><span class="built_in">List</span>&lt;Dept&gt; depts = session<span class="built_in">.</span>createQuery(hql)<span class="built_in">.</span>setLong(<span class="string">"id"</span>, <span class="literal">new</span> Long(inputId))<span class="built_in">.</span>setString(<span class="string">"likename"</span>, <span class="string">"%"</span>+inputName+<span class="string">"%"</span>)<span class="built_in">.</span><span class="built_in">list</span>();</span><br></pre></td></tr></table></figure></p>
<p>按参数位置绑定，”?”<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String hql = <span class="string">"from Dept where id&gt; ? and name like ?"</span>;</span><br><span class="line">List&lt;Dept&gt; depts = session.createQuery(hql).setLong(<span class="number">0</span>, <span class="keyword">new</span> Long(inputId)).setString(<span class="number">1</span>, <span class="string">"%"</span>+inputName+<span class="string">"%"</span>).<span class="built_in">list</span>();</span><br></pre></td></tr></table></figure></p>
<p>(5)distinct过滤重复值</p>
<p>(6)聚集函数</p>
<ul>
<li>count()</li>
<li>avg()</li>
<li>sum()</li>
<li>max()</li>
<li>min()<br>(7) order by 对结果排序</li>
</ul>
<p>默认是升序，关键字asc表示升序，desc表示降序。</p>
<p>(8)group by对记录分组</p>
<p>(9)having 对分组后数据进行条件过滤<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String hql = "<span class="operator"><span class="keyword">select</span> <span class="keyword">e</span>.dept.<span class="keyword">name</span> <span class="keyword">from</span> Employee <span class="keyword">e</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">e</span>.dept <span class="keyword">having</span> <span class="keyword">count</span>(<span class="keyword">e</span>)&gt;<span class="number">1</span><span class="string">"</span></span></span><br></pre></td></tr></table></figure></p>
<p>4，分页查询</p>
<p>当批量查询数据时，如果数据量非常大，怎么办？</p>
<ul>
<li>setFistResult(int firstResult):设置从第几条数据开始查询</li>
<li>setMaxResults(int maxResult)：设置每次查询的返回的最大对象数<figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static <span class="type">List</span>&lt;<span class="type">Employee</span>&gt; findEmployees(<span class="built_in">int</span> pageNo, <span class="built_in">int</span> pageSize)&#123;</span><br><span class="line">    <span class="type">SessionFactory</span> sessionFactory = new <span class="type">Configuration</span><span class="literal">()</span>.configure<span class="literal">()</span>.buildSessionFactory<span class="literal">()</span>;</span><br><span class="line">    <span class="type">Session</span> session = sessionFactory.openSession<span class="literal">()</span>;</span><br><span class="line">    session.beginTransaction<span class="literal">()</span>;</span><br><span class="line">    <span class="type">String</span> hql = <span class="string">"from Employee"</span></span><br><span class="line">    <span class="type">List</span>&lt;<span class="type">Employee</span>&gt; empls = session.<span class="type">CreateQuery</span>(hql).setFirstResult((pageNo-<span class="number">1</span>)*pageSize).setMaxResults(pageSize).<span class="built_in">list</span><span class="literal">()</span>;</span><br><span class="line">    session.getTransaction<span class="literal">()</span>.commit<span class="literal">()</span>;</span><br><span class="line">    session.close<span class="literal">()</span>;</span><br><span class="line">    return empls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>5，批量修改和删除</p>
<p>Hibernate3中新增update 和delete语句。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Query query = session.createQuery("<span class="operator"><span class="keyword">delete</span> Dept <span class="keyword">d</span> <span class="keyword">where</span> <span class="keyword">d</span>.<span class="keyword">name</span> <span class="keyword">like</span> :likename<span class="string">").setString("</span>likename<span class="string">","</span>%三%<span class="string">");</span><br><span class="line">int count = query.executeUpdate();</span></span></span><br></pre></td></tr></table></figure></p>
<p>6，连接查询</p>
<p>类似于SQL，支持连接查询<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inner <span class="function"><span class="title">join</span><span class="params">(内连接)</span></span>：可简写为join。列出这些相关联的实体类中满足连接条件的对象。</span><br><span class="line"><span class="attribute">left</span> outer <span class="function"><span class="title">join</span><span class="params">(左连接)</span></span>：可简写为<span class="attribute">left</span> join。不仅列出来这些相关联实体类中满足连接条件的对象，而且还包含连接左边的实体类中所有符合搜索条件(where 条件或者having 条件)</span><br><span class="line"><span class="attribute">right</span> outer <span class="function"><span class="title">join</span><span class="params">(右连接)</span></span>：<span class="attribute">right</span> join。不仅列出来这些相关联实体类中满足连接条件的对象，而且还包含连接右边的实体类中所有符合搜索条件(where 条件或者having 条件)</span><br><span class="line">full <span class="function"><span class="title">join</span><span class="params">(全连接)</span></span></span><br></pre></td></tr></table></figure></p>
<p>7，抓取连接查询</p>
<p>fetch来做数据抓取，所谓抓取，是指从数据库加载一个对象的数据时，同时把它所关联的对象和集合的数据都一起加载出来，以便减少SQL语句的数据，从而提高查询效率。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> hql = <span class="string">"FROM Dept d LEFT JOIN FETCH d.employees e WHERE d.name LIKE '%web%'"</span>;</span><br><span class="line"><span class="built_in">List</span>&lt;Dept&gt; <span class="built_in">list</span> = session<span class="built_in">.</span>createQuery(hql)<span class="built_in">.</span><span class="built_in">list</span>();</span><br><span class="line"><span class="built_in">Set</span>&lt;Dept&gt; depts = <span class="literal">new</span> HashSet&lt;Dept&gt; (<span class="built_in">list</span>);</span><br><span class="line">f<span class="subst">or</span>(Dept dept : depts)&#123;</span><br><span class="line">f<span class="subst">or</span>(Employee empl : dept<span class="built_in">.</span>getEmployees())&#123;</span><br><span class="line">empl<span class="built_in">.</span>getLoginName();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>8，子查询<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> hql = <span class="string">"FROM Dept d WHERE (SELECT COUNT(E) FROM d.employees e)&gt;1"</span>;</span><br><span class="line"><span class="built_in">List</span>&lt;Dept&gt; <span class="built_in">list</span> = session<span class="built_in">.</span>createQuery(hql)<span class="built_in">.</span><span class="built_in">list</span>();</span><br><span class="line">f<span class="subst">or</span>(Dept dept : <span class="built_in">list</span>)&#123;</span><br><span class="line">dept<span class="built_in">.</span>getName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>9，命名查询</p>
<p>命名查询是指将HQL查询语句编写在映射文件里，在程序中通过Session的getNameQuery()方法来获取。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">hibernate-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"org.napu.Dept"</span>&gt;</span><span class="tag">&lt;/<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">query</span> <span class="attribute">name</span>=<span class="value">"findDeptsByCondition"</span>&gt;</span></span><br><span class="line"><span class="cdata">&lt;![CDATA[from Dept d where d.name like :likename]]&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">query</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">hibernate-mapping</span>&gt;</span></span><br><span class="line">List<span class="tag">&lt;<span class="title">Dept</span>&gt;</span> depts = session.getNamedQuery("findEdeptsByCondition").setString("likeName","%a%").list();</span><br></pre></td></tr></table></figure></p>
<h2 id="Criteria_Queries">Criteria Queries</h2><p>Criteria叫标准化条件查询，它是一种比HQL更加面向对象的查询语言。QBC（Query By Criteria），特别适当在运行时才能创建查询条件的查询。程序开发时不知道，程序运行时才知道。</p>
<h3 id="Native_SQL_Queries">Native SQL Queries</h3><p>1，实体查询<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">String</span> sql = <span class="string">"SELECT * FROM dept WHERE id &gt; :id limit 3"</span>;</span><br><span class="line"><span class="type">List</span>&lt;<span class="type">Dept</span>&gt; depts = session.createSQLQuery(sql).addEntity(<span class="type">Dept</span>.class).setLong(“id”,<span class="number">1</span>).list();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">Dept</span> dept : depts)&#123;</span><br><span class="line">dept.getName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//_____</span><br><span class="line"><span class="type">String</span> sql = <span class="string">"Select &#123;d.*&#125;, &#123;e.*&#125; FROM dept d JOIN employee e ON d.id = e.dept_id"</span>;</span><br><span class="line"><span class="type">List</span> list = session.<span class="type">CreateSQLQuery</span>(sql).addEntity(<span class="string">"d"</span>,<span class="type">Dept</span>.class).addEntity(<span class="string">"e"</span>,<span class="type">Employee</span>.class).list();</span><br><span class="line"><span class="keyword">for</span>( <span class="type">Iterator</span> it = list.<span class="keyword">iterator</span>(); it.hasNext();)&#123;</span><br><span class="line">    <span class="type">Object</span>[] obj = (<span class="type">Object</span>[]) <span class="keyword">iterator</span>.next();</span><br><span class="line">    <span class="type">Dept</span> dept = (<span class="type">Dept</span>)obj[<span class="number">0</span>];</span><br><span class="line">    <span class="type">Employee</span> empl = (<span class="type">Employee</span>) obj[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2，标量查询</p>
<p>将查询结果转化为标量值。.addScalar(“countNum”,Hibernate.LONG)</p>
<p>3，定义成命名查询来使用<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">sql-query</span> <span class="attribute">name</span>=<span class="value">"findDeptAndEmployee"</span>&gt;</span></span><br><span class="line"><span class="cdata">&lt;![CDATA[Select &#123;d.*&#125;, &#123;e.*&#125; FROM dept d JOIN employee e ON d.id = e.dept_id]]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">return</span> <span class="attribute">alias</span>=<span class="value">"d"</span> <span class="attribute">class</span>=<span class="value">"org.napu.Dept"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">return</span> <span class="attribute">alias</span>=<span class="value">"e"</span> <span class="attribute">class</span>=<span class="value">"org.napu.Employee"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">sql-query</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="调用存储过程">调用存储过程</h3><p>1，编写过程<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="function"><span class="keyword">procedure</span> <span class="title">select_depts_by_likename</span><span class="params">(<span class="keyword">in</span> likeName varchar(20)</span>)</span><br><span class="line"><span class="title">begin</span></span><br><span class="line">    <span class="title">select</span> * <span class="title">from</span> <span class="title">dept</span> <span class="title">where</span> <span class="title">name</span> <span class="title">like</span> <span class="title">likeName</span>;</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></p>
<p>2，把过程映射为命名查询<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;sql-query <span class="property">name</span>=<span class="string">"findDeptAndEmployee"</span>&gt;</span><br><span class="line">&lt;<span class="constant">return</span> <span class="type">alias</span>=<span class="string">"d"</span> <span class="type">class</span>=<span class="string">"org.napu.Dept"</span>&gt;</span><br><span class="line">&lt;<span class="constant">return</span>-<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"id"</span> column=<span class="string">"id"</span>/&gt;</span><br><span class="line">&lt;<span class="constant">return</span>-<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"name"</span> column=<span class="string">"name"</span>/&gt;</span><br><span class="line">&lt;<span class="constant">return</span>-<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"createdTime"</span> column=<span class="string">"created_time"</span>/&gt;</span><br><span class="line">&lt;/<span class="constant">return</span>&gt;</span><br><span class="line">&#123;call select_depts_by_likename(:likeName)&#125;</span><br><span class="line">&lt;/sql-query&gt;</span><br></pre></td></tr></table></figure></p>
<p>3，调用过程<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;Dept&gt; depts = session<span class="built_in">.</span>getNamedQuery(<span class="string">"findEdeptsByCondition"</span>)<span class="built_in">.</span>setString(<span class="string">"likeName"</span>,<span class="string">"%a%"</span>)<span class="built_in">.</span><span class="built_in">list</span>();</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/05/07/Hibernate 数据查询/" data-id="cihrkq5pq005uestj6m5a3cq8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HQL/">HQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/QBC/">QBC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Query/">Query</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stored-procedure/">stored procedure</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Hibernate高级映射" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/05/Hibernate高级映射/" class="article-date">
  <time datetime="2015-05-05T06:49:44.000Z" itemprop="datePublished">2015-05-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Hibernate/">Hibernate</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/05/Hibernate高级映射/">Hibernate高级映射</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="集合映射">集合映射</h3><p>&lt;set java.util.Set or java.util.SortSet&gt;&lt;list java.util.List&gt;&lt;bag java.util.Collection&gt;&lt;idbag&gt;&lt;map java.util.Map or java.util.SortMap&gt;&lt;primitive-array&gt;&lt;array&gt;</p>
<h3 id="组件映射">组件映射</h3><p>&lt;component&gt;</p>
<p>1，组件类作为持久化类的单个属性</p>
<p>2，组件类作为持久化类的集合属性：集合映射中的类</p>
<p>3，组件类作为持久化类的对象标识符属性：数据库采用联合主键</p>
<h3 id="管理关系映射">管理关系映射</h3><p>关联关系是在领域模型建模中经常使用到的一种关系，它是对现实世界中事物之间的关系最基本的表示。</p>
<p>管联关系指的是不同持久化类之间的一种结构关系，简单地说，关联关系描述某个对象在一段时间内一直知道另一个对象的存在。</p>
<p>关联关系包括多样性关联和方向性关联。多样性（一对多，多对多），方向性（单项关联，双向关联）</p>
<p>映射关联关系就是把对象模型中类之间的关联关系映射成关系模型中数据库表之间的外键引用关系。在映射设计时，考虑两个问题：一是如何将对象模型中的对象之间的关系保存在关系模型的数据库表中，二是如何从关系模型的数据库表中检索出对象模型中的关联的对象。</p>
<p>1，单向多对一</p>
<p>多个员工属于同一部门</p>
<p>Department.hbm.xml</p>
<p>Employee.hbm.xml</p>
<p>&lt;many-to-one name=”dept” column=”dept_id”&gt;</p>
<p>2，单向一对一</p>
<p>Citizen.hbm.xml</p>
<p>&lt;many-to-one name=”idCard” column=”idcard_id” unique=”true” cascade=”all”&gt;</p>
<p>IdCard.hbm.xml</p>
<p>每个公民只有一张身份证，这就是典型的一对一关联关系。</p>
<p>3，双向一对一</p>
<p>基于唯一外键的一对一双向关联</p>
<p>Citizen.hbm.xml</p>
<p>&lt;many-to-one name=”idCard” column=”idcard_id” unique=”true” cascade=”all”/&gt;</p>
<p>IDCard.hbm.xml</p>
<p>&lt;one-to-one name=”citizen” property-ref=”idCard”/&gt;</p>
<p>基于主键的双向一对一关联</p>
<p>Citizen.hbm.xml</p>
<p>&lt;generator class=”foreign”&gt;&lt;param name=”property”&gt;idCard&lt;/param&gt;&lt;/generator&gt;</p>
<p>&lt;one-to-one name=”idCard” constrained=”true” cascade=”all”/&gt;</p>
<p>IDCard.hbm.xml</p>
<p>&lt;one-to-one name=”citizen”/&gt;</p>
<p>4，单向一对多</p>
<p>一个账号可以有多个订单</p>
<pre>//Order.java
public class Order{
  private Long id;
  private String orderNo;
  private Date createdTime;
  public Order(){}
}
//Account.java
public class Account{
  private Long id;
  private String loginName;
  private Set&lt;Order&gt; orderSet;
  public Account(){}
}
//Account.hbm.xml
&lt;set name="orderSet" cascade="save-update"&gt;
    &lt;key column="account_id"/&gt;
    &lt;one-to-many class="org.napu.Order"&gt;
&lt;set&gt;</pre>
5，双向一对多（多对一）
<pre>//Order.java
public class Order{
  private Long id;
  private String orderNo;
  private Date createdTime;
  private Account account;
  public Order(){}
}
//Account.java
public class Account{
  private Long id;
  private String loginName;
  private Set&lt;Order&gt; orderSet;
  public Account(){}
}
//Order.hbm.xml
&lt;many-to-one name="account" column="account_id" not-null="true"/&gt;
//Account.hbm.xml
&lt;Set name="orderSet" cascade="all" inverse="true"&gt;
    &lt;key column="account_id"/&gt;
    &lt;one-to-many class="org.napu.Order"&gt;
&lt;/Set&gt;</pre>
6，单向多对多

大学生和课程之间的关系
<pre>//Student.java
public class Student{
  private Long id;
  private String name;
  private String grade;
  private Set&lt;Course&gt; courses;
  public Student(){}
}
//Course.java
public class Course{
  private Long id;
  private String name;
  private Double creditHours;
  public Course(){}
}
//Student.hbm.xml
&lt;set name="courses" table="student_course"&gt;
    &lt;key column="student_id"/&gt;
    &lt;many-to-many column="course_id" class="org.napu.Course"&gt;
&lt;set&gt;</pre>
7，双向多对多
<pre>//Student.java
public class Student{
  private Long id;
  private String name;
  private String grade;
  private Set&lt;Course&gt; courses;
  public Student(){}
}
//Course.java
public class Course{
  private Long id;
  private String name;
  private Double creditHours;
  private Set&lt;Student&gt; students;
  public Course(){}
}
//Student.hbm.xml
&lt;set name="courses" table="student_course"&gt;
    &lt;key column="student_id"/&gt;
    &lt;many-to-many column="course_id" class="org.napu.Course"/&gt;
&lt;set&gt;
//Course.hbm.xml
&lt;set name=""students table="students_course" inverse="true"&gt;
    &lt;key column="course_id"/&gt;
    &lt;many-to-many column="student_id" class="org.napu.Student"/&gt;
&lt;/set&gt;</pre>

<h3 id="继承关系映射">继承关系映射</h3><p>继承在对象模型中是is a(是一个)的关系，在关系模型中，实体之间只有has a(有一个)的关系。</p>
<p>Hibernate提供了3中继承映射的方法。</p>
<p><pre>//Singer.java<br>public class Singer{<br>  private Long id;<br>  private String name;<br>  private String region;<br>  private String description;<br>  pubic Singer(){}<br>}<br>//SingleSinger.java<br>public class SingleSinger extends Singer{<br>  private Character gender;<br>  public SingleSinger(){}<br>}<br>//Bands.java<br>public class Bands extends Singer{<br>  private String leader;<br>  public Bands(){}<br>}</pre><br>1，整个继承层次一张表</p>
<p><pre>//Singer.hbm.xml<br>&lt;hibernate-mapping&gt;<br> &lt;class name=”org.napu.Singer” table=”singer”&gt;<br>  &lt;id name=”id” column=”id” type=”long”&gt;&lt;generator class=”native”/&gt;&lt;/id&gt;<br>  &lt;discriminator column=”type” type=”string”/&gt;<br>  &lt;property name=”name”/&gt;<br>  &lt;property name=”region”/&gt;<br>  &lt;property name=”description”/&gt;<br>  &lt;subclass name=”org.napu.SingleSinger” discriminator-value=”S”&gt;<br>    &lt;property name=”gender”/&gt;<br>  &lt;/subclass&gt;<br>  &lt;subclass name=”org.napu.Bands” discriminator-value=”B”&gt;<br>    &lt;property name=”leader”/&gt;<br>  &lt;/subclass&gt;<br> &lt;/class&gt;<br>&lt;/hibernate-mapping&gt;</pre><br>2，每个子类一张表</p>
<p><pre>&lt;joined-subclass name=”org.napu.SingleSinger” table=”single_singer”&gt;<br>  &lt;key column=”singler_id”/&gt;<br>  &lt;property name=”gender”/&gt;<br>&lt;/joined-subclass&gt;<br>…</pre><br>3，每个具体类一张表</p>
<p><pre>&lt;union-subclass name=”org.napu.SingleSinger” table=”single_singer”&gt;<br>  &lt;property name=”gender”/&gt;<br>&lt;/union-subclass&gt;<br>…</pre><br>一些经验：</p>
<ul>
<li>如果不需要多态查询：使用每个具体类一张表。</li>
<li>一定要使用多态查询：子类中的属性相对较少，使用每个层次一张表。</li>
<li>子类中属性较多，使用每个子类一张表。</li>
<li>简单的问题一般选择每个层次继承一张表，复杂案例一般选择每个子类一张表</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/05/05/Hibernate高级映射/" data-id="cihrkq5pj005pestjr39u18dh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hibernate/">Hibernate</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/对象映射/">对象映射</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-操纵Session" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/05/操纵Session/" class="article-date">
  <time datetime="2015-05-04T21:28:31.000Z" itemprop="datePublished">2015-05-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Hibernate/">Hibernate</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/05/操纵Session/">操纵Session</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Session接口可以说是Hibernate框架中使用最多的一个接口，它负责持久化工作、负责管理持久化对象的声明周期、提供第一级别的高级缓存来保证持久化对象的数据和数据库同步。</p>
<p>1，Session的缓存</p>
<p>Java中，缓存通常是指Java对象的属性占用的内存空间，一般使用集合类型的属性来作为缓存。Session这一级别的缓存通常称之为一级缓存，是由它的实现类SeeionImpl中的成员属性persistenceContext中定义的一系列Java集合（Map）属性构成。</p>
<p>当程序调用Session的CRUD方法以及调用查询几口list(),iterate()和filter()方法时，如果Session缓存中不存在对象，则加入第一级缓存，如果Session中已经存在这个对象，则不需要去数据库架子而是直接调用缓存，减少数据库访问的频率，提高程序效率。</p>
<p>当调用Transaction的commit()事务提交方法时，会自动进行缓存清理和数据库同步。</p>
<p>Session的缓存一般交由Hibernate框架自动管理而无需程序员干预。</p>
<p>2，持久化生命周期</p>
<p>一个持久化类的实例，在持久化生命周期中会在不同状态之间转变。Hibernate定义四种状态。</p>
<p><img src="http://img.dnbcw.info/2011129/3715650.gif" alt=""></p>
<p>1，瞬时状态(transient)</p>
<p>该实例是用new创建的，还没有被持久化，不处于任何Session的缓存中，它没有对象标识符。不跟任何一个Session关联，在数据库中没有对应的记录。</p>
<p>2，持久化状态(persistent)</p>
<p>已经被持久化，加入到Session缓存中。实例目前与某个Session关联。它拥有对象标识符值，并且可能在数据库中找到一个对应的行。Hibernate保证在同一个Session实例的缓存中，数据库中的每条记录只对应唯一一个持久化实例。持久化对象总是被一个Session实例关联。持久化实例和数据库中的相关记录对应，Session在清理缓存时，会根据持久化实例的属性数据变化，同步更新数据库。</p>
<p>3，移除状态(removed)</p>
<p>如果一个对象已经被计划在一个Session中结束时删除，它就处于移除状态，但仍然处于Session的缓存中，直到工作单元结束。</p>
<p>4，托管(detached)</p>
<p>已经被持久化过，但已经不处于Session的缓存中。不再位于Session的缓存中，但它拥有对象标识符。</p>
<p>Session的基本操作</p>
<p>public Serializable save(Object obj) throws HibernateException：持久化瞬时实例，返回对象标识符。</p>
<p>public Object get(Class clazz, Serializable id) throws HibernateException：根据制定OID找到一个持久化类。</p>
<p>public Object loadClass clazz, Serializable id) throws HibernateException：类似于get</p>
<p>public void delete(Object object) throws HibernateException：把指定的持久化类实例变成顺时状态，并从数据库表中移除对应的记录。</p>
<p>public void update(Object object) throws HibernateException：重附托管对象，并把它的状态更新到数据库表中。</p>
<p>public void saveOrUpdate(Object obj) throws HibernateException： 同时具有save()和update()的功能</p>
<p>public Object merge(Object object) throws HibernateException：将给定实例的状态复制到具有相同标识符的持久化实例上，并返回这个持久化实例。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/05/05/操纵Session/" data-id="cihrkq5js000uestj9g0vh2qh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hibernate/">Hibernate</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Session/">Session</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Hibernate 基本配置及操作" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/04/Hibernate 基本配置及操作/" class="article-date">
  <time datetime="2015-05-04T01:14:14.000Z" itemprop="datePublished">2015-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Hibernate/">Hibernate</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/04/Hibernate 基本配置及操作/">Hibernate 基本配置及操作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Hibernate_全局配置文件">Hibernate 全局配置文件</h3><p>1，hibernate.properties；hibernate.cfg.xml;</p>
<p>hibernate框架在启动的时候会在应用的ClassPath路径中查询有没有这两个文件，如果有则加载他们的配置参数。</p>
<p>在hibernate.cfg.xml文件中，首先配置session-factory元素来指定一个SessionFactory的配置，</p>
<p><pre>&lt;hibernate-configuration&gt;<br>&lt;session-factory&gt;<br>&lt;property name=”hibernate.dialect”&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;<br>&lt;/session-factory&gt;<br>&lt;/hibernate-configuration&gt;</pre><br>2， JDBC属性</p>
<ul>
<li>hibernate.connection.url</li>
<li>hibernate.connection.driver_class</li>
<li>hibernate.connection.username</li>
<li>hibernate.connection.password</li>
<li>hibernate.connection.isolation：设置JDBC事务的隔离级别</li>
<li>hibernate.connection.batch_size：批量操作的记录数<br>3，连接池属性</li>
</ul>
<p>通常要使用第三方的连接池技术。C3P0这个开源的连接池产品为例进行链接数据库参数的配置。</p>
<p><pre>&lt;property name=”hibernate.c3p0.min_size”&gt;5&lt;/property&gt;<br>&lt;property name=”hibernate.c3p0.max_size”&gt;20&lt;/property&gt;<br>&lt;property name=”hibernate.c3p0.timeout”&gt;1800&lt;/property&gt;<br>&lt;property name=”hibernate.c3p0.max_statement”&gt;100&lt;/property&gt;</pre><br>4，缓存属性</p>
<p>用来配置Hibernate使用的二级缓存策略。常用的配置如下：</p>
<ul>
<li>hibernate.cache.provider_class：指定第三方的缓存提供类的名称。ehcache缓存插件可做为Hibernate的二级缓存提供者。org.hibernate.cache.EhCacheProvider</li>
<li><p>hibernate.cache.use_query_cache：指定是否开启Hibernate的查询缓存。可选值为false和true。默认为false。<br>5，其他属性</p>
</li>
<li><p>hibernate.show_sql：指定是否把Hibernate运行时的SQL语句输出到控制台。</p>
</li>
<li>hibernate.format_sql：指定是否对Hibernate运行时产生的SQL语句进行格式化便于阅读。</li>
<li>hibernate.hbm2ddl.auto：指定应用程序在运行时，当产生SessionFactory实例时对是否自动检查数据库结构，或者将数据库schema的DDL导出到数据库。可选值：Validate（检查数据库结构），update（数据库结构发生变化时修改），create（将数据库schema的DDL导出到数据库），create_drop（在SessionFactory中实例创建时间数据schema的DDL导出到数据库，在SessionFactory被显示关闭时将数据库自动删除）。</li>
<li>hibernate.current_session_context_class：为当前Session指定一个策略。常用值：jta(当前Session根据JTA来跟踪和界定)、Thread（前Session通过当前执行的线程来跟踪和界定）</li>
</ul>
<h3 id="对象关系映射文件">对象关系映射文件</h3><p>Hibernate的对象关系映射文件把面相对象中的实体类对象映射到数据库中的实体，把实体类之间的关联关系也映射到数据库中多个表之间的相互关系中。</p>
<p><pre>XML文件的起始行，指定XML的版本和编码方式<br>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>映射文件的所使用的DTD声明<br>&lt;!DOCTYPE hibernate-mapping PUBLIC<br> “-//Hibernate/Hibernate Mapping DTD 3.0//EN”<br> “<a href="http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&amp;gt" target="_blank" rel="external">http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&amp;gt</a>;</pre></p>
<p>&lt;!– Hibernate对象关系映射文件的根元素 –&gt;<br>&lt;hibernate-mapping&gt;<br> &lt;!– class元素用来定义一个持久化类及对应的数据库表 –&gt;<br> &lt;class name=”com.qiujy.domain.Account” table=”account”&gt;<br> &lt;!–<br> id元素：指定每个持久化类的唯一标识(即对象标识符OID)到数据库表主键字段的映射<br> name属性：指定持久化类的OID名<br> column属性：指定数据库表主键字段名。此属性的名和映射到数据库表的字段名相同时，可省略<br> type属性：指定主键映射时所使用的Hibernate类型名。此属性的类型为基本数据类型和String类型时，可省略<br> –&gt;<br> &lt;id name=”id” column=”id” type=”long”&gt;<br> &lt;!– generator元素：指定对象标识符的生成器名。<br> native生成器把对象标识符值的生成工作交由底层数据库来完成<br> –&gt;<br> &lt;generator class=”native” /&gt;<br> &lt;/id&gt;<br> &lt;!–<br> property元素：指定持久化类的每一个要映射到数据库表的字段的属性的信息。<br> name属性；指定持久化类中要映射到数据库表字段的属性名。<br> column属性：指定对应的表的字段名。此属性的名和映射到数据库表的字段名相同时，可省略<br> type属性：指定属性映射所使用的Hibernate类型名。此属性的类型为基本数据类型和String类型时，可省略<br> not-null属性：指定此属性映射到数据库表的字段值是否允许为值<br> –&gt;<br> &lt;property name=”loginname” column=”loginname” type=”string” not-null=”true”/&gt;<br> &lt;property name=”password” column=”password” type=”string” not-null=”true”/&gt;<br> &lt;property name=”email” column=”email” type=”string”/&gt;<br> &lt;!– 属性类型为Date类型的必须要明确指定使用的Hibernate类型名 –&gt;<br> &lt;property name=”registrationTime” column=”registration_time” type=”timestamp”/&gt;<br> &lt;/class&gt;<br>&lt;/hibernate-mapping&gt;<br>1,映射持久化类</p>
<p>在Hibernate对象关系映射文件中，使用class元素来映射持久化类到数据库表中</p>
<ul>
<li>name：指定要映射的持久化类的名称</li>
<li>table：指定和此持久化类对应的数据库表名<br>2，映射对象标识符</li>
</ul>
<p>Hibernate中要求每一个持久化类都有一个对象标识符来唯一标识它的每一个实例。对象标识符的值是数据库表中行的主键。</p>
<p>3，对象标识符生成方式</p>
<p>可以通过ID元素的generator子元素，指定对象标识符的生成器。</p>
<ol>
<li>代理对象标识符：在一个持久化类中添加一个没有业务意义的属性来作为对象标识符，这样应用程序的领域模型更具有扩展性。</li>
<li>自然对象标识符：由许多遗留的SQL数据模型使用了带有业务意义的主键组成。</li>
</ol>
<ul>
<li>如果对象标识符的数据类型为整数型（Long，int，short）或对应的包装类型，为提高应用程序在不同数据库上的移植能力，建议使用native。</li>
<li>如果对象标识符的数据类型的为字符串型，为提高应用程序的在不同数据库上的移植能力，建议用UUID。</li>
<li>如果应用程序是先有数据库的物理模型后偶建立实体模型，且使用了自然主键，那么选择assigned.<br>4，映射普通属性</li>
</ul>
<p>对象标识符，版本号，自定义数据类型属性以外的属性。通过class元素的property子元素来映射&lt;property name=”属性名” column=”列名称” type=“映射属性”/&gt;</p>
<p>5，Hibernate映射的数据类型</p>
<p><img src="http://www.educity.cn/article_images/2014-03-18/11810dd6-1bfb-4478-92ca-471f8942ba92.jpg" alt=""></p>
<p>&nbsp;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/05/04/Hibernate 基本配置及操作/" data-id="cihrkq5pv0064estjsisv36sc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Configuration/">Configuration</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hibernate/">Hibernate</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ORM（Object Relation Mapping）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/03/ORM（Object Relation Mapping）/" class="article-date">
  <time datetime="2015-05-03T01:38:47.000Z" itemprop="datePublished">2015-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/03/ORM（Object Relation Mapping）/">ORM（Object Relation Mapping）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言">前言</h2><p>对象关系映射，是一种完成对象模型到关系模型的映射技术。就是一种把应用程序的对象数据持久化到关系数据库表的一种技术。</p>
<ul>
<li>把对象的数据转储到关系型数据库表中时就会发生如下不匹配的问题。</li>
<li>对象模型中对象之间的关联关系与关系模型中数据库表之间的关系无法一一对应。</li>
<li>对象模型中对象的继承关系在关系模型中无法直接表示。</li>
<li>对象模型中对象的等值性在关系模型数据库表中表示困难。</li>
<li>对象模型中有关联的对象之间的导航访问在关系模型中无法直接实现。<br>ORM 来解决上述问题。它能用面向对象的思想开发基于关系型数据库的应用程序。</li>
</ul>
<h3 id="Hibernate">Hibernate</h3><p>JBoss公司著名架构师Gavin King设计，开发的一个开源的ORM框架。</p>
<ul>
<li>它是连接Java应用程序和关系数据库的中间件。</li>
<li>它对JDBC API进行了封装，负责Java对象的持久化。</li>
<li>在分层的软件框架中它位于持久化层，封装的所有的数据访问细节，使业务逻辑层可以专注于实现业务逻辑。</li>
<li>它是一种ORM工具，能够建立面相对象的域模型和关系模型的映射。</li>
</ul>
<h3 id="hibernate_的核心类和接口">hibernate 的核心类和接口</h3><h4 id="1，Configuration类">1，Configuration类</h4><p>Configuration类是Hibernate的入口，它负责配置并启动Hibernate。Hibernate框架通过Configuration实例加载配置文件信息，然后读取指定对象关系文件的内容并创建SessionFactory实例。</p>
<h4 id="2，SessionFactory接口">2，SessionFactory接口</h4><p>SessionFactory接口负责初始化Hibernate，一个SessionFactory实例对应一个数据存储源（一般就是指一个数据库）。应用程序从SessionFactory中获取Session实例。SessionFactory具有以下几个特点：</p>
<ul>
<li>线程安全，即同一个SessionFactory实例可以被应用的多个线程共享。</li>
<li>它是重量级的，因为它需要一个很大的缓存，用来存放预定义的SQL语句以及映射元数据。<br>所以说，如果一个应用程序只访问一个数据库，则只需要创建一个全局的SessionFactory实例。</li>
</ul>
<h4 id="3，Session接口">3，Session接口</h4><p>Session是Hibernate中应用最频繁的接口。Session也被称为持久化管理器。他负责管理所有与持久化相关的操作：存储、更新、删除和加载对象等。Session具有以下特点。</p>
<p>单线程，非共享的对象。线程不安全，在设计软件架构时，应该避免多个线程共享同一个Session实例。</p>
<p>Session实例是轻量级的，它的创建和销毁不需要消耗太多的资源。可以为每个请求分配一个Session实例，在每次请求过程中及时创建和销毁Session实例。</p>
<p>Session有一个缓存，他存放当前工作单元加载的对象。Session的缓存被称为Hibernate的第一级缓存。</p>
<h4 id="4，Transaction接口">4，Transaction接口</h4><p>Transaction接口是Hibernate框架的事务接口。它对底层事务接口做了封装，包括：JDBC API和JTA。这样，使得Hibernate应用可通过一致的Transaction接口来声明事务边界，这有助于应用程序在不同环境和容器中移植。</p>
<h4 id="5，Query和Criteria接口">5，Query和Criteria接口</h4><p>他们是Hibernate的查询接口，用于从数据库存储源查询对象以及控制执行查询的过程。Query包装了一个HQL的查询语句；而Criteria接口完全封装了基于字符串形式的查询语句，比Query更加面相对象，Criteria接口擅长执行动态查询。</p>
<h3 id="Hibernate的工作过程">Hibernate的工作过程</h3><p><img src="http://img.my.csdn.net/uploads/201304/07/1365329836_2944.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zhaohuizhang.github.io/2015/05/03/ORM（Object Relation Mapping）/" data-id="cihrkq5p20059estjzcf3xpao" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hibernate/">Hibernate</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ORM/">ORM</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Flask/">Flask</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hibernate/">Hibernate</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Struts/">Struts</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/fibonacci/">fibonacci</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/socket/">socket</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Abstract/">Abstract</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bloom-Filter/">Bloom Filter</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Classpath/">Classpath</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collections/">Collections</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Configuration/">Configuration</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DTD/">DTD</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Deadlock/">Deadlock</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Duplicate-from-Array/">Duplicate from Array</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Exception/">Exception</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flask-migrate/">Flask migrate</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HQL/">HQL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hashmap/">Hashmap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hibernate/">Hibernate</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Interface/">Interface</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaIO/">JavaIO</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Login/">Login</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVC/">MVC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NIO/">NIO</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OOP/">OOP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ORM/">ORM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Path/">Path</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/QBC/">QBC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Query/">Query</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SVN/">SVN</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Schema/">Schema</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scrapy/">Scrapy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Session/">Session</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sublime-Text2-Plugins-install/">Sublime Text2 Plugins install</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tag/">Tag</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tiles/">Tiles</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tokens/">Tokens</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Validation/">Validation</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XML/">XML</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/component/">component</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/concurrent/">concurrent</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/crawler/">crawler</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hashtable/">hashtable</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javaIO/">javaIO</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/">markdown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/">mongodb</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/multiThread/">multiThread</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-yield/">python yield</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-rq/">python-rq</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/srcapy/">srcapy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stored-procedure/">stored procedure</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/struts/">struts</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/study/">study</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/work-principal/">work principal</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中文乱码/">中文乱码</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/全栈工程师/">全栈工程师</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式爬虫/">分布式爬虫</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/对象映射/">对象映射</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据挖掘/">数据挖掘</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文本处理/">文本处理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/机器学习/">机器学习</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/科学计算/">科学计算</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络爬虫/">网络爬虫</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Abstract/" style="font-size: 10px;">Abstract</a> <a href="/tags/Bloom-Filter/" style="font-size: 10px;">Bloom Filter</a> <a href="/tags/Classpath/" style="font-size: 10px;">Classpath</a> <a href="/tags/Collections/" style="font-size: 10px;">Collections</a> <a href="/tags/Configuration/" style="font-size: 10px;">Configuration</a> <a href="/tags/DTD/" style="font-size: 10px;">DTD</a> <a href="/tags/Deadlock/" style="font-size: 10px;">Deadlock</a> <a href="/tags/Duplicate-from-Array/" style="font-size: 10px;">Duplicate from Array</a> <a href="/tags/Exception/" style="font-size: 10px;">Exception</a> <a href="/tags/Flask-migrate/" style="font-size: 10px;">Flask migrate</a> <a href="/tags/HQL/" style="font-size: 10px;">HQL</a> <a href="/tags/Hashmap/" style="font-size: 10px;">Hashmap</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Hibernate/" style="font-size: 17.5px;">Hibernate</a> <a href="/tags/Interface/" style="font-size: 10px;">Interface</a> <a href="/tags/JavaIO/" style="font-size: 10px;">JavaIO</a> <a href="/tags/Login/" style="font-size: 10px;">Login</a> <a href="/tags/MVC/" style="font-size: 10px;">MVC</a> <a href="/tags/NIO/" style="font-size: 17.5px;">NIO</a> <a href="/tags/OOP/" style="font-size: 10px;">OOP</a> <a href="/tags/ORM/" style="font-size: 10px;">ORM</a> <a href="/tags/Path/" style="font-size: 10px;">Path</a> <a href="/tags/QBC/" style="font-size: 10px;">QBC</a> <a href="/tags/Query/" style="font-size: 10px;">Query</a> <a href="/tags/SVN/" style="font-size: 10px;">SVN</a> <a href="/tags/Schema/" style="font-size: 10px;">Schema</a> <a href="/tags/Scrapy/" style="font-size: 10px;">Scrapy</a> <a href="/tags/Session/" style="font-size: 10px;">Session</a> <a href="/tags/Sublime-Text2-Plugins-install/" style="font-size: 10px;">Sublime Text2 Plugins install</a> <a href="/tags/Tag/" style="font-size: 10px;">Tag</a> <a href="/tags/Tiles/" style="font-size: 10px;">Tiles</a> <a href="/tags/Tokens/" style="font-size: 10px;">Tokens</a> <a href="/tags/Validation/" style="font-size: 10px;">Validation</a> <a href="/tags/XML/" style="font-size: 10px;">XML</a> <a href="/tags/component/" style="font-size: 10px;">component</a> <a href="/tags/concurrent/" style="font-size: 10px;">concurrent</a> <a href="/tags/crawler/" style="font-size: 10px;">crawler</a> <a href="/tags/hashtable/" style="font-size: 10px;">hashtable</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/javaIO/" style="font-size: 10px;">javaIO</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/multiThread/" style="font-size: 10px;">multiThread</a> <a href="/tags/python/" style="font-size: 12.5px;">python</a> <a href="/tags/python-yield/" style="font-size: 10px;">python yield</a> <a href="/tags/python-rq/" style="font-size: 10px;">python-rq</a> <a href="/tags/srcapy/" style="font-size: 10px;">srcapy</a> <a href="/tags/stored-procedure/" style="font-size: 10px;">stored procedure</a> <a href="/tags/struts/" style="font-size: 20px;">struts</a> <a href="/tags/study/" style="font-size: 10px;">study</a> <a href="/tags/work-principal/" style="font-size: 10px;">work principal</a> <a href="/tags/中文乱码/" style="font-size: 10px;">中文乱码</a> <a href="/tags/全栈工程师/" style="font-size: 10px;">全栈工程师</a> <a href="/tags/分布式爬虫/" style="font-size: 10px;">分布式爬虫</a> <a href="/tags/对象映射/" style="font-size: 10px;">对象映射</a> <a href="/tags/数据挖掘/" style="font-size: 10px;">数据挖掘</a> <a href="/tags/文本处理/" style="font-size: 10px;">文本处理</a> <a href="/tags/机器学习/" style="font-size: 10px;">机器学习</a> <a href="/tags/科学计算/" style="font-size: 10px;">科学计算</a> <a href="/tags/网络爬虫/" style="font-size: 12.5px;">网络爬虫</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a><span class="archive-list-count">18</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a><span class="archive-list-count">15</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/12/03/IO-Contrast/">IO-Contrast</a>
          </li>
        
          <li>
            <a href="/2015/12/03/AIO/">AIO</a>
          </li>
        
          <li>
            <a href="/2015/12/02/NIO-library/">NIO-library</a>
          </li>
        
          <li>
            <a href="/2015/11/30/NIO-Introduce-Abstractly/">NIO-Introduce-Abstractly</a>
          </li>
        
          <li>
            <a href="/2015/11/30/java-I-O-2/">java-I/O-2</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 Zhaohui zhang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>